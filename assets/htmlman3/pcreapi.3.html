<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

  <title>pcreapi(3) — Linux manual pages</title>
  <link rel="stylesheet" type="text/css" href="../stylesheet/manpages.css" />
  
  <link rel="home" href="../index.html" title="pcreapi(3) — Linux manual pages" />
  <script type="text/javascript" src="../stylesheet/manpages.js" xml:space="preserve">
</script>
  <link rel="icon" href="../stylesheet/icon.gif" type="image/gif" />
</head>

<body onload="javascript:init()">
  <div class="navheader">
    <table width="100%">
      <tbody>
        <tr>
          <td style="width: 33%" rowspan="1" colspan="1"><a href="../index.html" shape="rect">Linux
          manual pages</a></td>

          <th rowspan="1" colspan="1"><a href="../index3.html" shape="rect">Section 3</a></th>

          <td style="width: 33%" rowspan="1" colspan="1"> </td>
        </tr>
      </tbody>
    </table>
    <hr />
  </div>

  <div class="refentry" title="pcreapi(3) — Linux manual pages">
    <a id="pcreapi.3" name="pcreapi.3" shape="rect"> </a>

    <div class="titlepage"> </div>

    <div class="refnamediv">
      <h2>Name</h2>

      <p>PCRE — Perl-compatible regular expressions #include
      &lt;pcre.h&gt; . .</p>
    </div>

    <div class="refsect1" title="PCRE NATIVE API BASIC FUNCTIONS">
      <a id="pcreapi-3_sect1" name="pcreapi-3_sect1" shape="rect"> </a>

      <h2>PCRE NATIVE API BASIC FUNCTIONS</h2>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">pcre
            *<strong>pcre_compile</strong>(</code></td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">pattern</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">options</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char **<var class="pdparam">errptr</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">erroffset</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const unsigned char *<var class="pdparam">tableptr</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">pcre
            *<strong>pcre_compile2</strong>(</code></td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">pattern</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">options</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">errorcodeptr</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char **<var class="pdparam">errptr</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">erroffset</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const unsigned char *<var class="pdparam">tableptr</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">pcre_extra
            *<strong>pcre_study</strong>(</code></td>

            <td rowspan="1" colspan="1">const pcre *<var class="pdparam">code</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">options</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char **<var class="pdparam">errptr</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">void
            <strong>pcre_free_study</strong>(</code></td>

            <td rowspan="1" colspan="1">pcre_extra *<var class="pdparam">extra</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int
            <strong>pcre_exec</strong>(</code></td>

            <td rowspan="1" colspan="1">const pcre *<var class="pdparam">code</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const pcre_extra *<var class="pdparam">extra</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">subject</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">length</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">startoffset</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">options</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">ovector</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">ovecsize</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int
            <strong>pcre_dfa_exec</strong>(</code></td>

            <td rowspan="1" colspan="1">const pcre *<var class="pdparam">code</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const pcre_extra *<var class="pdparam">extra</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">subject</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">length</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">startoffset</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">options</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">ovector</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">ovecsize</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">workspace</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">wscount</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>
    </div>

    <div class="refsect1" title="PCRE NATIVE API STRING EXTRACTION FUNCTIONS">
      <a id="pcreapi-3_sect2" name="pcreapi-3_sect2" shape="rect"> </a>

      <h2>PCRE NATIVE API STRING EXTRACTION FUNCTIONS</h2>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int
            <strong>pcre_copy_named_substring</strong>(</code></td>

            <td rowspan="1" colspan="1">const pcre *<var class="pdparam">code</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">subject</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">ovector</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">stringcount</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">stringname</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">char *<var class="pdparam">buffer</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">buffersize</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int
            <strong>pcre_copy_substring</strong>(</code></td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">subject</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">ovector</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">stringcount</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">stringnumber</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">char *<var class="pdparam">buffer</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">buffersize</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int
            <strong>pcre_get_named_substring</strong>(</code></td>

            <td rowspan="1" colspan="1">const pcre *<var class="pdparam">code</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">subject</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">ovector</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">stringcount</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">stringname</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char **<var class="pdparam">stringptr</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int
            <strong>pcre_get_stringnumber</strong>(</code></td>

            <td rowspan="1" colspan="1">const pcre *<var class="pdparam">code</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">name</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int
            <strong>pcre_get_stringtable_entries</strong>(</code></td>

            <td rowspan="1" colspan="1">const pcre *<var class="pdparam">code</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">name</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">char **<var class="pdparam">first</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">char **<var class="pdparam">last</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int
            <strong>pcre_get_substring</strong>(</code></td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">subject</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">ovector</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">stringcount</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">stringnumber</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char **<var class="pdparam">stringptr</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int
            <strong>pcre_get_substring_list</strong>(</code></td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">subject</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">ovector</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">stringcount</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char ***<var class="pdparam">listptr</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">void
            <strong>pcre_free_substring</strong>(</code></td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">stringptr</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">void
            <strong>pcre_free_substring_list</strong>(</code></td>

            <td rowspan="1" colspan="1">const char **<var class="pdparam">stringptr</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>
    </div>

    <div class="refsect1" title="PCRE NATIVE API AUXILIARY FUNCTIONS">
      <a id="pcreapi-3_sect3" name="pcreapi-3_sect3" shape="rect"> </a>

      <h2>PCRE NATIVE API AUXILIARY FUNCTIONS</h2>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">pcre_jit_stack
            *<strong>pcre_jit_stack_alloc</strong>(</code></td>

            <td rowspan="1" colspan="1">int <var class="pdparam">startsize</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">maxsize</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">void
            <strong>pcre_jit_stack_free</strong>(</code></td>

            <td rowspan="1" colspan="1">pcre_jit_stack *<var class="pdparam">stack</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">void
            <strong>pcre_assign_jit_stack</strong>(</code></td>

            <td rowspan="1" colspan="1">pcre_extra *<var class="pdparam">extra</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">pcre_jit_callback <var class="pdparam">callback</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">void *<var class="pdparam">data</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">const unsigned char
            *<strong>pcre_maketables</strong>(</code></td>

            <td rowspan="1" colspan="1"><code>void)</code>;</td>

            <td rowspan="1" colspan="1"> </td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int
            <strong>pcre_fullinfo</strong>(</code></td>

            <td rowspan="1" colspan="1">const pcre *<var class="pdparam">code</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const pcre_extra *<var class="pdparam">extra</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">what</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">void *<var class="pdparam">where</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int
            <strong>pcre_refcount</strong>(</code></td>

            <td rowspan="1" colspan="1">pcre *<var class="pdparam">code</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">adjust</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int
            <strong>pcre_config</strong>(</code></td>

            <td rowspan="1" colspan="1">int <var class="pdparam">what</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">void *<var class="pdparam">where</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">const char
            *<strong>pcre_version</strong>(</code></td>

            <td rowspan="1" colspan="1"><code>void)</code>;</td>

            <td rowspan="1" colspan="1"> </td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int
            <strong>pcre_pattern_to_host_byte_order</strong>(</code></td>

            <td rowspan="1" colspan="1">pcre *<var class="pdparam">code</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">pcre_extra *<var class="pdparam">extra</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const unsigned char *<var class="pdparam">tables</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>
    </div>

    <div class="refsect1" title="PCRE NATIVE API INDIRECTED FUNCTIONS">
      <a id="pcreapi-3_sect4" name="pcreapi-3_sect4" shape="rect"> </a>

      <h2>PCRE NATIVE API INDIRECTED FUNCTIONS</h2>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">void
            <strong>*</strong>(</code></td>

            <td rowspan="1" colspan="1">*pcre_malloc)(<var class="pdparam">size_t</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef"><strong>void</strong>(</code></td>

            <td rowspan="1" colspan="1"><var class="pdparam">*pcre_free)(void
            *</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">void
            <strong>*</strong>(</code></td>

            <td rowspan="1" colspan="1">*pcre_stack_malloc)(<var class="pdparam">size_t</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef"><strong>void</strong>(</code></td>

            <td rowspan="1" colspan="1"><var class="pdparam">*pcre_stack_free)(void
            *</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef"><strong>int</strong>(</code></td>

            <td rowspan="1" colspan="1"><var class="pdparam">*pcre_callout)(pcre_callout_block
            *</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>
    </div>

    <div class="refsect1" title="PCRE 8-BIT AND 16-BIT LIBRARIES">
      <a id="pcreapi-3_sect5" name="pcreapi-3_sect5" shape="rect"> </a>

      <h2>PCRE 8-BIT AND 16-BIT LIBRARIES</h2>

      <p>From release 8.30, PCRE can be compiled as a library for
      handling 16-bit character strings as well as, or instead of,
      the original library that handles 8-bit character strings. To
      avoid too much complication, this document describes the
      8-bit versions of the functions, with only occasional
      references to the 16-bit library.</p>

      <p>The 16-bit functions operate in the same way as their
      8-bit counterparts; they just use different data types for
      their arguments and results, and their names start with
      <code class="function">pcre16_</code> instead of <code class="function">pcre_</code>. For every option that has UTF8 in
      its name (for example, PCRE_UTF8), there is a corresponding
      16-bit name with UTF8 replaced by UTF16. This facility is in
      fact just cosmetic; the 16-bit option names define the same
      bit values.</p>

      <p>References to bytes and UTF-8 in this document should be
      read as references to 16-bit data quantities and UTF-16 when
      using the 16-bit library, unless specified otherwise. More
      details of the specific differences for the 16-bit library
      are given in the <a class="link" href="../htmlman3/pcre16.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre16</span>(3)</span></a> page.</p>
    </div>

    <div class="refsect1" title="PCRE API OVERVIEW">
      <a id="pcreapi-3_sect6" name="pcreapi-3_sect6" shape="rect"> </a>

      <h2>PCRE API OVERVIEW</h2>

      <p>PCRE has its own native API, which is described in this
      document. There are also some wrapper functions (for the
      8-bit library only) that correspond to the POSIX regular
      expression API, but they do not give access to all the
      functionality. They are described in the <a class="link" href="../htmlman3/pcreposix.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcreposix</span>(3)</span></a> documentation.
      Both of these APIs define a set of C function calls. A C++
      wrapper (again for the 8-bit library only) is also
      distributed with PCRE. It is documented in the <a class="link" href="../htmlman3/pcrecpp.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrecpp</span>(3)</span></a> page.</p>

      <p>The native API C function prototypes are defined in the
      header file <code class="filename">pcre.h</code>, and on
      Unix-like systems the (8-bit) library itself is called
      <em class="citetitle">libpcre</em>. It can normally be
      accessed by adding <code class="option">−lpcre</code>
      to the command for linking an application that uses PCRE. The
      header file defines the macros PCRE_MAJOR and PCRE_MINOR to
      contain the major and minor release numbers for the library.
      Applications can use these to include support for different
      releases of PCRE.</p>

      <p>In a Windows environment, if you want to statically link
      an application program against a non-dll <em class="replaceable"><code>pcre.a</code></em> file, you must define
      PCRE_STATIC before including <code class="filename">pcre.h</code> or <code class="filename">pcrecpp.h</code>, because otherwise the
      <code class="function">pcre_malloc</code>() and <code class="function">pcre_free</code>() exported functions will be
      declared <em class="replaceable"><code>__declspec(dllimport)</code></em>, with
      unwanted results.</p>

      <p>The functions <code class="function">pcre_compile</code>(), <code class="function">pcre_compile2</code>(), <code class="function">pcre_study</code>(), and <code class="function">pcre_exec</code>() are used for compiling and
      matching regular expressions in a Perl-compatible manner. A
      sample program that demonstrates the simplest way of using
      them is provided in the file called <code class="filename">pcredemo.c</code> in the PCRE source distribution.
      A listing of this program is given in the <span class="citerefentry"><span class="refentrytitle">pcredemo</span>(3)</span> documentation, and
      the <a class="link" href="../htmlman3/pcresample.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcresample</span>(3)</span></a> documentation
      describes how to compile and run it.</p>

      <p>Just-in-time compiler support is an optional feature of
      PCRE that can be built in appropriate hardware environments.
      It greatly speeds up the matching performance of many
      patterns. Simple programs can easily request that it be used
      if available, by setting an option that is ignored when it is
      not relevant. More complicated programs might need to make
      use of the functions <code class="function">pcre_jit_stack_alloc</code>(), <code class="function">pcre_jit_stack_free</code>(), and <code class="function">pcre_assign_jit_stack</code>() in order to control
      the JIT code's memory usage. These functions are discussed in
      the <a class="link" href="../htmlman3/pcrejit.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrejit</span>(3)</span></a>
      documentation.</p>

      <p>A second matching function, <code class="function">pcre_dfa_exec</code>(), which is not
      Perl-compatible, is also provided. This uses a different
      algorithm for the matching. The alternative algorithm finds
      all possible matches (at a given point in the subject), and
      scans the subject just once (unless there are lookbehind
      assertions). However, this algorithm does not return captured
      substrings. A description of the two matching algorithms and
      their advantages and disadvantages is given in the <a class="link" href="../htmlman3/pcrematching.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrematching</span>(3)</span></a>
      documentation.</p>

      <p>In addition to the main compiling and matching functions,
      there are convenience functions for extracting captured
      substrings from a subject string that is matched by
      <code class="function">pcre_exec</code>(). They are:</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 <code class="function">pcre_copy_substring</code>()
 <code class="function">pcre_copy_named_substring</code>()
 <code class="function">pcre_get_substring</code>()
 <code class="function">pcre_get_named_substring</code>()
 <code class="function">pcre_get_substring_list</code>()
 <code class="function">pcre_get_stringnumber</code>()
 <code class="function">pcre_get_stringtable_entries</code>()
</pre>
      </div>

      <p><code class="function">pcre_free_substring</code>() and
      <code class="function">pcre_free_substring_list</code>() are
      also provided, to free the memory used for extracted
      strings.</p>

      <p>The function <code class="function">pcre_maketables</code>() is used to build a set of
      character tables in the current locale for passing to
      <code class="function">pcre_compile</code>(), <code class="function">pcre_exec</code>(), or <code class="function">pcre_dfa_exec</code>(). This is an optional
      facility that is provided for specialist use. Most commonly,
      no special tables are passed, in which case internal tables
      that are generated when PCRE is built are used.</p>

      <p>The function <code class="function">pcre_fullinfo</code>()
      is used to find out information about a compiled pattern. The
      function <code class="function">pcre_version</code>() returns
      a pointer to a string containing the version of PCRE and its
      date of release.</p>

      <p>The function <code class="function">pcre_refcount</code>()
      maintains a reference count in a data block containing a
      compiled pattern. This is provided for the benefit of
      object-oriented applications.</p>

      <p>The global variables <code class="function">pcre_malloc</code> and <code class="function">pcre_free</code> initially contain the entry
      points of the standard <code class="function">malloc</code>()
      and <code class="function">free</code>() functions,
      respectively. PCRE calls the memory management functions via
      these variables, so a calling program can replace them if it
      wishes to intercept the calls. This should be done before
      calling any PCRE functions.</p>

      <p>The global variables <code class="function">pcre_stack_malloc</code> and <code class="function">pcre_stack_free</code> are also indirections to
      memory management functions. These special functions are used
      only when PCRE is compiled to use the heap for remembering
      data, instead of recursive function calls, when running the
      <code class="function">pcre_exec</code>() function. See the
      <a class="link" href="../htmlman3/pcrebuild.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrebuild</span>(3)</span></a> documentation
      for details of how to do this. It is a non-standard way of
      building PCRE, for use in environments that have limited
      stacks. Because of the greater use of memory management, it
      runs more slowly. Separate functions are provided so that
      special-purpose external code can be used for this case. When
      used, these functions are always called in a stack-like
      manner (last obtained, first freed), and always for memory
      blocks of the same size. There is a discussion about PCRE's
      stack usage in the <a class="link" href="../htmlman3/pcrestack.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrestack</span>(3)</span></a>
      documentation.</p>

      <p>The global variable <code class="function">pcre_callout</code> initially contains NULL. It
      can be set by the caller to a "callout" function, which PCRE
      will then call at specified points during a matching
      operation. Details are given in the <a class="link" href="../htmlman3/pcrecallout.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrecallout</span>(3)</span></a>
      documentation.</p>
    </div>

    <div class="refsect1" title="NEWLINES">
      <a id="pcreapi-3_sect7" name="pcreapi-3_sect7" shape="rect"> </a>

      <h2>NEWLINES</h2>

      <p>PCRE supports five different conventions for indicating
      line breaks in strings: a single CR (carriage return)
      character, a single LF (linefeed) character, the
      two-character sequence CRLF, any of the three preceding, or
      any Unicode newline sequence. The Unicode newline sequences
      are the three just mentioned, plus the single characters VT
      (vertical tab, U+000B), FF (form feed, U+000C), NEL (next
      line, U+0085), LS (line separator, U+2028), and PS (paragraph
      separator, U+2029).</p>

      <p>Each of the first three conventions is used by at least
      one operating system as its standard newline sequence. When
      PCRE is built, a default can be specified. The default
      default is LF, which is the Unix standard. When PCRE is run,
      the default can be overridden, either when a pattern is
      compiled, or when it is matched.</p>

      <p>At compile time, the newline convention can be specified
      by the <em class="parameter"><code>options</code></em>
      argument of <code class="function">pcre_compile</code>(), or
      it can be specified by special text at the start of the
      pattern itself; this overrides any other settings. See the
      <a class="link" href="../htmlman3/pcrepattern.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrepattern</span>(3)</span></a> page for
      details of the special character sequences.</p>

      <p>In the PCRE documentation the word "newline" is used to
      mean "the character or pair of characters that indicate a
      line break". The choice of newline convention affects the
      handling of the dot, circumflex, and dollar metacharacters,
      the handling of #-comments in /x mode, and, when CRLF is a
      recognized line ending sequence, the match position
      advancement for a non-anchored pattern. There is more detail
      about this in the section on <code class="function">pcre_exec</code>() options below.</p>

      <p>The choice of newline convention does not affect the
      interpretation of the \n or \r escape sequences, nor does it
      affect what \R matches, which is controlled in a similar way,
      but by separate options.</p>
    </div>

    <div class="refsect1" title="MULTITHREADING">
      <a id="pcreapi-3_sect8" name="pcreapi-3_sect8" shape="rect"> </a>

      <h2>MULTITHREADING</h2>

      <p>The PCRE functions can be used in multi-threading
      applications, with the proviso that the memory management
      functions pointed to by <code class="function">pcre_malloc</code>, <code class="function">pcre_free</code>, <code class="function">pcre_stack_malloc</code>, and <code class="function">pcre_stack_free</code>, and the callout function
      pointed to by <code class="function">pcre_callout</code>, are
      shared by all threads.</p>

      <p>The compiled form of a regular expression is not altered
      during matching, so the same compiled pattern can safely be
      used by several threads at once.</p>

      <p>If the just-in-time optimization feature is being used, it
      needs separate memory stack areas for each thread. See the
      <a class="link" href="../htmlman3/pcrejit.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrejit</span>(3)</span></a> documentation
      for more details.</p>
    </div>

    <div class="refsect1" title="SAVING PRECOMPILED PATTERNS FOR LATER USE">
      <a id="pcreapi-3_sect9" name="pcreapi-3_sect9" shape="rect"> </a>

      <h2>SAVING PRECOMPILED PATTERNS FOR LATER USE</h2>

      <p>The compiled form of a regular expression can be saved and
      re-used at a later time, possibly by a different program, and
      even on a host other than the one on which it was compiled.
      Details are given in the <a class="link" href="../htmlman3/pcreprecompile.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcreprecompile</span>(3)</span></a>
      documentation, which includes a description of the
      <code class="function">pcre_pattern_to_host_byte_order</code>() function.
      However, compiling a regular expression with one version of
      PCRE for use with a different version is not guaranteed to
      work and may cause crashes.</p>
    </div>

    <div class="refsect1" title="CHECKING BUILD-TIME OPTIONS">
      <a id="pcreapi-3_sect10" name="pcreapi-3_sect10" shape="rect"> </a>

      <h2>CHECKING BUILD-TIME OPTIONS</h2>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int
            <strong>pcre_config</strong>(</code></td>

            <td rowspan="1" colspan="1">int <var class="pdparam">what</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">void *<var class="pdparam">where</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <p>The function <code class="function">pcre_config</code>()
      makes it possible for a PCRE client to discover which
      optional features have been compiled into the PCRE library.
      The <a class="link" href="../htmlman3/pcrebuild.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrebuild</span>(3)</span></a> documentation
      has more details about these optional features.</p>

      <p>The first argument for <code class="function">pcre_config</code>() is an integer, specifying
      which information is required; the second argument is a
      pointer to a variable into which the information is placed.
      The returned value is zero on success, or the negative error
      code PCRE_ERROR_BADOPTION if the value in the first argument
      is not recognized. The following information is
      available:</p>

      <div class="variablelist">
        <dl>
          <dt><span class="term"><code class="constant">PCRE_CONFIG_UTF8</code></span></dt>

          <dd>
            <p>The output is an integer that is set to one if UTF-8
            support is available; otherwise it is set to zero. If
            this option is given to the 16-bit version of this
            function, <code class="function">pcre16_config</code>(), the result is
            PCRE_ERROR_BADOPTION.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_CONFIG_UTF16</code></span></dt>

          <dd>
            <p>The output is an integer that is set to one if
            UTF-16 support is available; otherwise it is set to
            zero. This value should normally be given to the 16-bit
            version of this function, <code class="function">pcre16_config</code>(). If it is given to
            the 8-bit version of this function, the result is
            PCRE_ERROR_BADOPTION.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_CONFIG_UNICODE_PROPERTIES</code></span></dt>

          <dd>
            <p>The output is an integer that is set to one if
            support for Unicode character properties is available;
            otherwise it is set to zero.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_CONFIG_JIT</code></span></dt>

          <dd>
            <p>The output is an integer that is set to one if
            support for just-in-time compiling is available;
            otherwise it is set to zero.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_CONFIG_JITTARGET</code></span></dt>

          <dd>
            <p>The output is a pointer to a zero-terminated "const
            char *" string. If JIT support is available, the string
            contains the name of the architecture for which the JIT
            compiler is configured, for example "x86 32bit (little
            endian + unaligned)". If JIT support is not available,
            the result is NULL.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_CONFIG_NEWLINE</code></span></dt>

          <dd>
            <p>The output is an integer whose value specifies the
            default character sequence that is recognized as
            meaning "newline". The four values that are supported
            are: 10 for LF, 13 for CR, 3338 for CRLF, -2 for
            ANYCRLF, and -1 for ANY. Though they are derived from
            ASCII, the same values are returned in EBCDIC
            environments. The default should normally correspond to
            the standard sequence for your operating system.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_CONFIG_BSR</code></span></dt>

          <dd>
            <p>The output is an integer whose value indicates what
            character sequences the \R escape sequence matches by
            default. A value of 0 means that \R matches any Unicode
            line ending sequence; a value of 1 means that \R
            matches only CR, LF, or CRLF. The default can be
            overridden when a pattern is compiled or matched.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_CONFIG_LINK_SIZE</code></span></dt>

          <dd>
            <p>The output is an integer that contains the number of
            bytes used for internal linkage in compiled regular
            expressions. For the 8-bit library, the value can be 2,
            3, or 4. For the 16-bit library, the value is either 2
            or 4 and is still a number of bytes. The default value
            of 2 is sufficient for all but the most massive
            patterns, since it allows the compiled pattern to be up
            to 64K in size. Larger values allow larger regular
            expressions to be compiled, at the expense of slower
            matching.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_CONFIG_POSIX_MALLOC_THRESHOLD</code></span></dt>

          <dd>
            <p>The output is an integer that contains the threshold
            above which the POSIX interface uses <code class="function">malloc</code>() for output vectors. Further
            details are given in the <a class="link" href="../htmlman3/pcreposix.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcreposix</span>(3)</span></a>
            documentation.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_CONFIG_MATCH_LIMIT</code></span></dt>

          <dd>
            <p>The output is a long integer that gives the default
            limit for the number of internal matching function
            calls in a <code class="function">pcre_exec</code>()
            execution. Further details are given with <code class="function">pcre_exec</code>() below.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_CONFIG_MATCH_LIMIT_RECURSION</code></span></dt>

          <dd>
            <p>The output is a long integer that gives the default
            limit for the depth of recursion when calling the
            internal matching function in a <code class="function">pcre_exec</code>() execution. Further
            details are given with <code class="function">pcre_exec</code>() below.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_CONFIG_STACKRECURSE</code></span></dt>

          <dd>
            <p>The output is an integer that is set to one if
            internal recursion when running <code class="function">pcre_exec</code>() is implemented by
            recursive function calls that use the stack to remember
            their state. This is the usual way that PCRE is
            compiled. The output is zero if PCRE was compiled to
            use blocks of data on the heap instead of recursive
            function calls. In this case, <code class="function">pcre_stack_malloc</code> and <code class="function">pcre_stack_free</code> are called to manage
            memory blocks on the heap, thus avoiding the use of the
            stack.</p>
          </dd>
        </dl>
      </div>
    </div>

    <div class="refsect1" title="COMPILING A PATTERN">
      <a id="pcreapi-3_sect11" name="pcreapi-3_sect11" shape="rect"> </a>

      <h2>COMPILING A PATTERN</h2>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">pcre
            *<strong>pcre_compile</strong>(</code></td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">pattern</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">options</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char **<var class="pdparam">errptr</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">erroffset</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const unsigned char *<var class="pdparam">tableptr</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">pcre
            *<strong>pcre_compile2</strong>(</code></td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">pattern</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">options</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">errorcodeptr</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char **<var class="pdparam">errptr</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">erroffset</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const unsigned char *<var class="pdparam">tableptr</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <p>Either of the functions <code class="function">pcre_compile</code>() or <code class="function">pcre_compile2</code>() can be called to compile a
      pattern into an internal form. The only difference between
      the two interfaces is that <code class="function">pcre_compile2</code>() has an additional argument,
      <em class="parameter"><code>errorcodeptr</code></em>, via
      which a numerical error code can be returned. To avoid too
      much repetition, we refer just to <code class="function">pcre_compile</code>() below, but the information
      applies equally to <code class="function">pcre_compile2</code>().</p>

      <p>The pattern is a C string terminated by a binary zero, and
      is passed in the <em class="parameter"><code>pattern</code></em> argument. A pointer to
      a single block of memory that is obtained via <code class="function">pcre_malloc</code> is returned. This contains the
      compiled code and related data. The <code class="function">pcre</code> type is defined for the returned
      block; this is a typedef for a structure whose contents are
      not externally defined. It is up to the caller to free the
      memory (via <code class="function">pcre_free</code>) when it
      is no longer required.</p>

      <p>Although the compiled code of a PCRE regex is relocatable,
      that is, it does not depend on memory location, the complete
      <code class="function">pcre</code> data block is not fully
      relocatable, because it may contain a copy of the <em class="parameter"><code>tableptr</code></em> argument, which is an
      address (see below).</p>

      <p>The <em class="parameter"><code>options</code></em>
      argument contains various bit settings that affect the
      compilation. It should be zero if no options are required.
      The available options are described below. Some of them (in
      particular, those that are compatible with Perl, but some
      others as well) can also be set and unset from within the
      pattern (see the detailed description in the <a class="link" href="../htmlman3/pcrepattern.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrepattern</span>(3)</span></a>
      documentation). For those options that can be different in
      different parts of the pattern, the contents of the
      <em class="parameter"><code>options</code></em> argument
      specifies their settings at the start of compilation and
      execution. The PCRE_ANCHORED, PCRE_BSR_<em class="replaceable"><code>xxx</code></em>, PCRE_NEWLINE_<em class="replaceable"><code>xxx</code></em>, PCRE_NO_UTF8_CHECK, and
      PCRE_NO_START_OPTIMIZE options can be set at the time of
      matching as well as at compile time.</p>

      <p>If <em class="parameter"><code>errptr</code></em> is NULL,
      <code class="function">pcre_compile</code>() returns NULL
      immediately. Otherwise, if compilation of a pattern fails,
      <code class="function">pcre_compile</code>() returns NULL,
      and sets the variable pointed to by <em class="parameter"><code>errptr</code></em> to point to a textual
      error message. This is a static string that is part of the
      library. You must not try to free it. Normally, the offset
      from the start of the pattern to the byte that was being
      processed when the error was discovered is placed in the
      variable pointed to by <em class="parameter"><code>erroffset</code></em>, which must not be
      NULL (if it is, an immediate error is given). However, for an
      invalid UTF-8 string, the offset is that of the first byte of
      the failing character.</p>

      <p>Some errors are not detected until the whole pattern has
      been scanned; in these cases, the offset passed back is the
      length of the pattern. Note that the offset is in bytes, not
      characters, even in UTF-8 mode. It may sometimes point into
      the middle of a UTF-8 character.</p>

      <p>If <code class="function">pcre_compile2</code>() is used
      instead of <code class="function">pcre_compile</code>(), and
      the <em class="parameter"><code>errorcodeptr</code></em>
      argument is not NULL, a non-zero error code number is
      returned via this argument in the event of an error. This is
      in addition to the textual error message. Error codes and
      messages are listed below.</p>

      <p>If the final argument, <em class="parameter"><code>tableptr</code></em>, is NULL, PCRE uses a
      default set of character tables that are built when PCRE is
      compiled, using the default C locale. Otherwise, <em class="parameter"><code>tableptr</code></em> must be an address
      that is the result of a call to <code class="function">pcre_maketables</code>(). This value is stored
      with the compiled pattern, and used again by <code class="function">pcre_exec</code>(), unless another table pointer
      is passed to it. For more discussion, see the section on
      locale support below.</p>

      <p>This code fragment shows a typical straightforward call to
      <code class="function">pcre_compile</code>():</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 pcre *re;
 const char *error;
 int erroffset;
 re = pcre_compile(
   "^A.*Z",          /* the pattern */
   0,                /* default options */
   &amp;error,           /* for error message */
   &amp;erroffset,       /* for error offset */
   NULL);            /* use default character tables */
</pre>
      </div>

      <p>The following names for option bits are defined in the
      <code class="filename">pcre.h</code> header file:</p>

      <div class="variablelist">
        <dl>
          <dt><span class="term"><code class="constant">PCRE_ANCHORED</code></span></dt>

          <dd>
            <p>If this bit is set, the pattern is forced to be
            "anchored", that is, it is constrained to match only at
            the first matching point in the string that is being
            searched (the "subject string"). This effect can also
            be achieved by appropriate constructs in the pattern
            itself, which is the only way to do it in Perl.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_AUTO_CALLOUT</code></span></dt>

          <dd>
            <p>If this bit is set, <code class="function">pcre_compile</code>() automatically inserts
            callout items, all with number 255, before each pattern
            item. For discussion of the callout facility, see the
            <a class="link" href="../htmlman3/pcrecallout.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrecallout</span>(3)</span></a>
            documentation.</p>

            <div class="informalexample">
              <pre class="programlisting" xml:space="preserve">
 PCRE_BSR_ANYCRLF
 PCRE_BSR_UNICODE
</pre>
            </div>

            <p>These options (which are mutually exclusive) control
            what the \R escape sequence matches. The choice is
            either to match only CR, LF, or CRLF, or to match any
            Unicode newline sequence. The default is specified when
            PCRE is built. It can be overridden from within the
            pattern, or by setting an option when a compiled
            pattern is matched.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_CASELESS</code></span></dt>

          <dd>
            <p>If this bit is set, letters in the pattern match
            both upper and lower case letters. It is equivalent to
            Perl's /i option, and it can be changed within a
            pattern by a (?i) option setting. In UTF-8 mode, PCRE
            always understands the concept of case for characters
            whose values are less than 128, so caseless matching is
            always possible. For characters with higher values, the
            concept of case is supported if PCRE is compiled with
            Unicode property support, but not otherwise. If you
            want to use caseless matching for characters 128 and
            above, you must ensure that PCRE is compiled with
            Unicode property support as well as with UTF-8
            support.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_DOLLAR_ENDONLY</code></span></dt>

          <dd>
            <p>If this bit is set, a dollar metacharacter in the
            pattern matches only at the end of the subject string.
            Without this option, a dollar also matches immediately
            before a newline at the end of the string (but not
            before any other newlines). The PCRE_DOLLAR_ENDONLY
            option is ignored if PCRE_MULTILINE is set. There is no
            equivalent to this option in Perl, and no way to set it
            within a pattern.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_DOTALL</code></span></dt>

          <dd>
            <p>If this bit is set, a dot metacharacter in the
            pattern matches a character of any value, including one
            that indicates a newline. However, it only ever matches
            one character, even if newlines are coded as CRLF.
            Without this option, a dot does not match when the
            current position is at a newline. This option is
            equivalent to Perl's /s option, and it can be changed
            within a pattern by a (?s) option setting. A negative
            class such as [^a] always matches newline characters,
            independent of the setting of this option.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_DUPNAMES</code></span></dt>

          <dd>
            <p>If this bit is set, names used to identify capturing
            subpatterns need not be unique. This can be helpful for
            certain types of pattern when it is known that only one
            instance of the named subpattern can ever be matched.
            There are more details of named subpatterns below; see
            also the <a class="link" href="../htmlman3/pcrepattern.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrepattern</span>(3)</span></a>
            documentation.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_EXTENDED</code></span></dt>

          <dd>
            <p>If this bit is set, white space data characters in
            the pattern are totally ignored except when escaped or
            inside a character class. White space does not include
            the VT character (code 11). In addition, characters
            between an unescaped # outside a character class and
            the next newline, inclusive, are also ignored. This is
            equivalent to Perl's /x option, and it can be changed
            within a pattern by a (?x) option setting.</p>
          </dd>
        </dl>
      </div>

      <p>Which characters are interpreted as newlines is controlled
      by the options passed to <code class="function">pcre_compile</code>() or by a special sequence at
      the start of the pattern, as described in the section
      entitled "Newline conventions" in the <code class="function">pcrepattern</code> documentation. Note that the
      end of this type of comment is a literal newline sequence in
      the pattern; escape sequences that happen to represent a
      newline do not count.</p>

      <p>This option makes it possible to include comments inside
      complicated patterns. Note, however, that this applies only
      to data characters. White space characters may never appear
      within special character sequences in a pattern, for example
      within the sequence (?( that introduces a conditional
      subpattern.</p>

      <div class="variablelist">
        <dl>
          <dt><span class="term"><code class="constant">PCRE_EXTRA</code></span></dt>

          <dd>
            <p>This option was invented in order to turn on
            additional functionality of PCRE that is incompatible
            with Perl, but it is currently of very little use. When
            set, any backslash in a pattern that is followed by a
            letter that has no special meaning causes an error,
            thus reserving these combinations for future expansion.
            By default, as in Perl, a backslash followed by a
            letter with no special meaning is treated as a literal.
            (Perl can, however, be persuaded to give an error for
            this, by running it with the -w option.) There are at
            present no other features controlled by this option. It
            can also be set by a (?X) option setting within a
            pattern.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_FIRSTLINE</code></span></dt>

          <dd>
            <p>If this option is set, an unanchored pattern is
            required to match before or at the first newline in the
            subject string, though the matched text may continue
            over the newline.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_JAVASCRIPT_COMPAT</code></span></dt>

          <dd>
            <p>If this option is set, PCRE's behaviour is changed
            in some ways so that it is compatible with JavaScript
            rather than Perl. The changes are as follows:</p>
          </dd>
        </dl>
      </div>

      <p>(1) A lone closing square bracket in a pattern causes a
      compile-time error, because this is illegal in JavaScript (by
      default it is treated as a data character). Thus, the pattern
      AB]CD becomes illegal when this option is set.</p>

      <p>(2) At run time, a back reference to an unset subpattern
      group matches an empty string (by default this causes the
      current matching alternative to fail). A pattern such as
      (\1)(a) succeeds when this option is set (assuming it can
      find an "a" in the subject), whereas it fails by default, for
      Perl compatibility.</p>

      <p>(3) \U matches an upper case "U" character; by default \U
      causes a compile time error (Perl uses \U to upper case
      subsequent characters).</p>

      <p>(4) \u matches a lower case "u" character unless it is
      followed by four hexadecimal digits, in which case the
      hexadecimal number defines the code point to match. By
      default, \u causes a compile time error (Perl uses it to
      upper case the following character).</p>

      <p>(5) \x matches a lower case "x" character unless it is
      followed by two hexadecimal digits, in which case the
      hexadecimal number defines the code point to match. By
      default, as in Perl, a hexadecimal number is always expected
      after \x, but it may have zero, one, or two digits (so, for
      example, \xz matches a binary zero character followed by
      z).</p>

      <div class="variablelist">
        <dl>
          <dt><span class="term"><code class="constant">PCRE_MULTILINE</code></span></dt>

          <dd>
            <p>By default, PCRE treats the subject string as
            consisting of a single line of characters (even if it
            actually contains newlines). The "start of line"
            metacharacter (^) matches only at the start of the
            string, while the "end of line" metacharacter ($)
            matches only at the end of the string, or before a
            terminating newline (unless PCRE_DOLLAR_ENDONLY is
            set). This is the same as Perl.</p>
          </dd>
        </dl>
      </div>

      <p>When PCRE_MULTILINE it is set, the "start of line" and
      "end of line" constructs match immediately following or
      immediately before internal newlines in the subject string,
      respectively, as well as at the very start and end. This is
      equivalent to Perl's /m option, and it can be changed within
      a pattern by a (?m) option setting. If there are no newlines
      in a subject string, or no occurrences of ^ or $ in a
      pattern, setting PCRE_MULTILINE has no effect.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 PCRE_NEWLINE_CR
 PCRE_NEWLINE_LF
 PCRE_NEWLINE_CRLF
 PCRE_NEWLINE_ANYCRLF
 PCRE_NEWLINE_ANY
</pre>
      </div>

      <p>These options override the default newline definition that
      was chosen when PCRE was built. Setting the first or the
      second specifies that a newline is indicated by a single
      character (CR or LF, respectively). Setting PCRE_NEWLINE_CRLF
      specifies that a newline is indicated by the two-character
      CRLF sequence. Setting PCRE_NEWLINE_ANYCRLF specifies that
      any of the three preceding sequences should be recognized.
      Setting PCRE_NEWLINE_ANY specifies that any Unicode newline
      sequence should be recognized. The Unicode newline sequences
      are the three just mentioned, plus the single characters VT
      (vertical tab, U+000B), FF (form feed, U+000C), NEL (next
      line, U+0085), LS (line separator, U+2028), and PS (paragraph
      separator, U+2029). For the 8-bit library, the last two are
      recognized only in UTF-8 mode.</p>

      <p>The newline setting in the options word uses three bits
      that are treated as a number, giving eight possibilities.
      Currently only six are used (default plus the five values
      above). This means that if you set more than one newline
      option, the combination may or may not be sensible. For
      example, PCRE_NEWLINE_CR with PCRE_NEWLINE_LF is equivalent
      to PCRE_NEWLINE_CRLF, but other combinations may yield unused
      numbers and cause an error.</p>

      <p>The only time that a line break in a pattern is specially
      recognized when compiling is when PCRE_EXTENDED is set. CR
      and LF are white space characters, and so are ignored in this
      mode. Also, an unescaped # outside a character class
      indicates a comment that lasts until after the next line
      break sequence. In other circumstances, line break sequences
      in patterns are treated as literal data.</p>

      <p>The newline option that is set at compile time becomes the
      default that is used for <code class="function">pcre_exec</code>() and <code class="function">pcre_dfa_exec</code>(), but it can be
      overridden.</p>

      <div class="variablelist">
        <dl>
          <dt><span class="term"><code class="constant">PCRE_NO_AUTO_CAPTURE</code></span></dt>

          <dd>
            <p>If this option is set, it disables the use of
            numbered capturing parentheses in the pattern. Any
            opening parenthesis that is not followed by ? behaves
            as if it were followed by ?: but named parentheses can
            still be used for capturing (and they acquire numbers
            in the usual way). There is no equivalent of this
            option in Perl.</p>
          </dd>

          <dt><span class="term"><code class="constant">NO_START_OPTIMIZE</code></span></dt>

          <dd>
            <p>This is an option that acts at matching time; that
            is, it is really an option for <code class="function">pcre_exec</code>() or <code class="function">pcre_dfa_exec</code>(). If it is set at
            compile time, it is remembered with the compiled
            pattern and assumed at matching time. For details see
            the discussion of PCRE_NO_START_OPTIMIZE below.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_UCP</code></span></dt>

          <dd>
            <p>This option changes the way PCRE processes \B, \b,
            \D, \d, \S, \s, \W, \w, and some of the POSIX character
            classes. By default, only ASCII characters are
            recognized, but if PCRE_UCP is set, Unicode properties
            are used instead to classify characters. More details
            are given in the section on generic character types in
            the <a class="link" href="../htmlman3/pcrepattern.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrepattern</span>(3)</span></a> page.
            If you set PCRE_UCP, matching one of the items it
            affects takes much longer. The option is available only
            if PCRE has been compiled with Unicode property
            support.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_UNGREEDY</code></span></dt>

          <dd>
            <p>This option inverts the "greediness" of the
            quantifiers so that they are not greedy by default, but
            become greedy if followed by "?". It is not compatible
            with Perl. It can also be set by a (?U) option setting
            within the pattern.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_UTF8</code></span></dt>

          <dd>
            <p>This option causes PCRE to regard both the pattern
            and the subject as strings of UTF-8 characters instead
            of single-byte strings. However, it is available only
            when PCRE is built to include UTF support. If not, the
            use of this option provokes an error. Details of how
            this option changes the behaviour of PCRE are given in
            the <a class="link" href="../htmlman3/pcreunicode.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcreunicode</span>(3)</span></a>
            page.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_NO_UTF8_CHECK</code></span></dt>

          <dd>
            <p>When PCRE_UTF8 is set, the validity of the pattern
            as a UTF-8 string is automatically checked. There is a
            discussion about the validity of UTF-8 strings in the
            <a class="link" href="../htmlman3/pcreunicode.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcreunicode</span>(3)</span></a> page.
            If an invalid UTF-8 sequence is found, <code class="function">pcre_compile</code>() returns an error. If
            you already know that your pattern is valid, and you
            want to skip this check for performance reasons, you
            can set the PCRE_NO_UTF8_CHECK option. When it is set,
            the effect of passing an invalid UTF-8 string as a
            pattern is undefined. It may cause your program to
            crash. Note that this option can also be passed to
            <code class="function">pcre_exec</code>() and
            <code class="function">pcre_dfa_exec</code>(), to
            suppress the validity checking of subject strings.</p>
          </dd>
        </dl>
      </div>
    </div>

    <div class="refsect1" title="COMPILATION ERROR CODES">
      <a id="pcreapi-3_sect12" name="pcreapi-3_sect12" shape="rect"> </a>

      <h2>COMPILATION ERROR CODES</h2>

      <p>The following table lists the error codes than may be
      returned by <code class="function">pcre_compile2</code>(),
      along with the error messages that may be returned by both
      compiling functions. Note that error messages are always
      8-bit ASCII strings, even in 16-bit mode. As PCRE has
      developed, some error codes have fallen out of use. To avoid
      confusion, they have not been re-used.</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
  0  no error
  1  \ at end of pattern
  2  \c at end of pattern
  3  unrecognized character follows \
  4  numbers out of order in {} quantifier
  5  number too big in {} quantifier
  6  missing terminating ] for character class
  7  invalid escape sequence in character class
  8  range out of order in character class
  9  nothing to repeat
 10  [this code is not in use]
 11  internal error: unexpected repeat
 12  unrecognized character after (? or (?-
 13  POSIX named classes are supported only within a class
 14  missing )
 15  reference to non-existent subpattern
 16  erroffset passed as NULL
 17  unknown option bit(s) set
 18  missing ) after comment
 19  [this code is not in use]
 20  regular expression is too large
 21  failed to get memory
 22  unmatched parentheses
 23  internal error: code overflow
 24  unrecognized character after (?&lt;
 25  lookbehind assertion is not fixed length
 26  malformed number or name after (?(
 27  conditional group contains more than two branches
 28  assertion expected after (?(
 29  (?R or (?[+-]digits must be followed by )
 30  unknown POSIX class name
 31  POSIX collating elements are not supported
 32  this version of PCRE is compiled without UTF support
 33  [this code is not in use]
 34  character value in \x{...} sequence is too large
 35  invalid condition (?(0)
 36  \C not allowed in lookbehind assertion
 37  PCRE does not support \L, \l, \N{name}, \U, or \u
 38  number after (?C is &gt; 255
 39  closing ) for (?C expected
 40  recursive call could loop indefinitely
 41  unrecognized character after (?P
 42  syntax error in subpattern name (missing terminator)
 43  two named subpatterns have the same name
 44  invalid UTF-8 string (specifically UTF-8)
 45  support for \P, \p, and \X has not been compiled
 46  malformed \P or \p sequence
 47  unknown property name after \P or \p
 48  subpattern name is too long (maximum 32 characters)
 49  too many named subpatterns (maximum 10000)
 50  [this code is not in use]
 51  octal value is greater than \377 in 8-bit non-UTF-8 mode
 52  internal error: overran compiling workspace
 53  internal error: previously-checked referenced subpattern
       not found
 54  DEFINE group contains more than one branch
 55  repeating a DEFINE group is not allowed
 56  inconsistent NEWLINE options
 57  \g is not followed by a braced, angle-bracketed, or quoted
       name/number or by a plain number
 58  a numbered reference must not be zero
 59  an argument is not allowed for (*ACCEPT), (*FAIL), or (*COMMIT)
 60  (*VERB) not recognized
 61  number is too big
 62  subpattern name expected
 63  digit expected after (?+
 64  ] is an invalid data character in JavaScript compatibility mode
 65  different names for subpatterns of the same number are
       not allowed
 66  (*MARK) must have an argument
 67  this version of PCRE is not compiled with Unicode property
       support
 68  \c must be followed by an ASCII character
 69  \k is not followed by a braced, angle-bracketed, or quoted name
 70  internal error: unknown opcode in find_fixedlength()
 71  \N is not supported in a class
 72  too many forward references
 73  disallowed Unicode code point (&gt;= 0xd800 &amp;&amp; &lt;= 0xdfff)
 74  invalid UTF-16 string (specifically UTF-16)
 75  name is too long in (*MARK), (*PRUNE), (*SKIP), or (*THEN)
 76  character value in \u.... sequence is too large
</pre>
      </div>

      <p>The numbers 32 and 10000 in errors 48 and 49 are defaults;
      different values may be used if the limits were changed when
      PCRE was built.</p>
    </div>

    <div class="refsect1" title="STUDYING A PATTERN">
      <a id="pcreapi-3_sect13" name="pcreapi-3_sect13" shape="rect"> </a>

      <h2>STUDYING A PATTERN</h2>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">pcre_extra
            *<strong>pcre_study</strong>(</code></td>

            <td rowspan="1" colspan="1">const pcre *<var class="pdparam">code</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int optionsconst char **<var class="pdparam">errptr</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <p>If a compiled pattern is going to be used several times,
      it is worth spending more time analyzing it in order to speed
      up the time taken for matching. The function <code class="function">pcre_study</code>() takes a pointer to a compiled
      pattern as its first argument. If studying the pattern
      produces additional information that will help speed up
      matching, <code class="function">pcre_study</code>() returns
      a pointer to a <span class="type">pcre_extra</span> block, in
      which the <em class="parameter"><code>study_data</code></em>
      field points to the results of the study.</p>

      <p>The returned value from <code class="function">pcre_study</code>() can be passed directly to
      <code class="function">pcre_exec</code>() or <code class="function">pcre_dfa_exec</code>(). However, a <span class="type">pcre_extra</span> block also contains other fields
      that can be set by the caller before the block is passed;
      these are described below in the section on matching a
      pattern.</p>

      <p>If studying the pattern does not produce any useful
      information, <code class="function">pcre_study</code>()
      returns NULL. In that circumstance, if the calling program
      wants to pass any of the other fields to <code class="function">pcre_exec</code>() or <code class="function">pcre_dfa_exec</code>(), it must set up its own
      <span class="type">pcre_extra</span> block.</p>

      <p>The second argument of <code class="function">pcre_study</code>() contains option bits. There
      are three options:</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 PCRE_STUDY_JIT_COMPILE
 PCRE_STUDY_JIT_PARTIAL_HARD_COMPILE
 PCRE_STUDY_JIT_PARTIAL_SOFT_COMPILE
</pre>
      </div>

      <p>If any of these are set, and the just-in-time compiler is
      available, the pattern is further compiled into machine code
      that executes much faster than the <code class="function">pcre_exec</code>() interpretive matching function.
      If the just-in-time compiler is not available, these options
      are ignored. All other bits in the <em class="parameter"><code>options</code></em> argument must be
      zero.</p>

      <p>JIT compilation is a heavyweight optimization. It can take
      some time for patterns to be analyzed, and for one-off
      matches and simple patterns the benefit of faster execution
      might be offset by a much slower study time. Not all patterns
      can be optimized by the JIT compiler. For those that cannot
      be handled, matching automatically falls back to the
      <code class="function">pcre_exec</code>() interpreter. For
      more details, see the <a class="link" href="../htmlman3/pcrejit.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrejit</span>(3)</span></a>
      documentation.</p>

      <p>The third argument for <code class="function">pcre_study</code>() is a pointer for an error
      message. If studying succeeds (even if no data is returned),
      the variable it points to is set to NULL. Otherwise it is set
      to point to a textual error message. This is a static string
      that is part of the library. You must not try to free it. You
      should test the error pointer for NULL after calling
      <code class="function">pcre_study</code>(), to be sure that
      it has run successfully.</p>

      <p>When you are finished with a pattern, you can free the
      memory used for the study data by calling <code class="function">pcre_free_study</code>(). This function was added
      to the API for release 8.20. For earlier versions, the memory
      could be freed with <code class="function">pcre_free</code>(), just like the pattern itself.
      This will still work in cases where JIT optimization is not
      used, but it is advisable to change to the new function when
      convenient.</p>

      <p>This is a typical way in which <code class="function">pcre_study</code>() is used (except that in a real
      application there should be tests for errors):</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 int rc;
 pcre *re;
 pcre_extra *sd;
 re = pcre_compile("pattern", 0, &amp;error, &amp;erroroffset, NULL);
 sd = pcre_study(
   re,             /* result of pcre_compile() */
   0,              /* no options */
   &amp;error);        /* set to NULL or points to a message */
 rc = pcre_exec(   /* see below for details of pcre_exec() options */
   re, sd, "subject", 7, 0, 0, ovector, 30);
 ...
 pcre_free_study(sd);
 pcre_free(re);
</pre>
      </div>

      <p>Studying a pattern does two things: first, a lower bound
      for the length of subject string that is needed to match the
      pattern is computed. This does not mean that there are any
      strings of that length that match, but it does guarantee that
      no shorter strings match. The value is used by <code class="function">pcre_exec</code>() and <code class="function">pcre_dfa_exec</code>() to avoid wasting time by
      trying to match strings that are shorter than the lower
      bound. You can find out the value in a calling program via
      the <code class="function">pcre_fullinfo</code>()
      function.</p>

      <p>Studying a pattern is also useful for non-anchored
      patterns that do not have a single fixed starting character.
      A bitmap of possible starting bytes is created. This speeds
      up finding a position in the subject at which to start
      matching. (In 16-bit mode, the bitmap is used for 16-bit
      values less than 256.)</p>

      <p>These two optimizations apply to both <code class="function">pcre_exec</code>() and <code class="function">pcre_dfa_exec</code>(), and the information is
      also used by the JIT compiler. The optimizations can be
      disabled by setting the PCRE_NO_START_OPTIMIZE option when
      calling <code class="function">pcre_exec</code>() or
      <code class="function">pcre_dfa_exec</code>(), but if this is
      done, JIT execution is also disabled. You might want to do
      this if your pattern contains callouts or (*MARK) and you
      want to make use of these facilities in cases where matching
      fails. See the discussion of PCRE_NO_START_OPTIMIZE
      below.</p>
    </div>

    <div class="refsect1" title="LOCALE SUPPORT">
      <a id="pcreapi-3_sect14" name="pcreapi-3_sect14" shape="rect"> </a>

      <h2>LOCALE SUPPORT</h2>

      <p>PCRE handles caseless matching, and determines whether
      characters are letters, digits, or whatever, by reference to
      a set of tables, indexed by character value. When running in
      UTF-8 mode, this applies only to characters with codes less
      than 128. By default, higher-valued codes never match escapes
      such as \w or \d, but they can be tested with \p if PCRE is
      built with Unicode character property support. Alternatively,
      the PCRE_UCP option can be set at compile time; this causes
      \w and friends to use Unicode property support instead of
      built-in tables. The use of locales with Unicode is
      discouraged. If you are handling characters with codes
      greater than 128, you should either use UTF-8 and Unicode, or
      use locales, but not try to mix the two.</p>

      <p>PCRE contains an internal set of tables that are used when
      the final argument of <code class="function">pcre_compile</code>() is NULL. These are
      sufficient for many applications. Normally, the internal
      tables recognize only ASCII characters. However, when PCRE is
      built, it is possible to cause the internal tables to be
      rebuilt in the default "C" locale of the local system, which
      may cause them to be different.</p>

      <p>The internal tables can always be overridden by tables
      supplied by the application that calls PCRE. These may be
      created in a different locale from the default. As more and
      more applications change to using Unicode, the need for this
      locale support is expected to die away.</p>

      <p>External tables are built by calling the <code class="function">pcre_maketables</code>() function, which has no
      arguments, in the relevant locale. The result can then be
      passed to <code class="function">pcre_compile</code>() or
      <code class="function">pcre_exec</code>() as often as
      necessary. For example, to build and use tables that are
      appropriate for the French locale (where accented characters
      with values greater than 128 are treated as letters), the
      following code could be used:</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 setlocale(LC_CTYPE, "fr_FR");
 tables = pcre_maketables();
 re = pcre_compile(..., tables);
</pre>
      </div>

      <p>The locale name "fr_FR" is used on Linux and other
      Unix-like systems; if you are using Windows, the name for the
      French locale is "french".</p>

      <p>When <code class="function">pcre_maketables</code>() runs,
      the tables are built in memory that is obtained via
      <code class="function">pcre_malloc</code>. It is the caller's
      responsibility to ensure that the memory containing the
      tables remains available for as long as it is needed.</p>

      <p>The pointer that is passed to <code class="function">pcre_compile</code>() is saved with the compiled
      pattern, and the same tables are used via this pointer by
      <code class="function">pcre_study</code>() and normally also
      by <code class="function">pcre_exec</code>(). Thus, by
      default, for any single pattern, compilation, studying and
      matching all happen in the same locale, but different
      patterns can be compiled in different locales.</p>

      <p>It is possible to pass a table pointer or NULL (indicating
      the use of the internal tables) to <code class="function">pcre_exec</code>(). Although not intended for this
      purpose, this facility could be used to match a pattern in a
      different locale from the one in which it was compiled.
      Passing table pointers at run time is discussed below in the
      section on matching a pattern.</p>
    </div>

    <div class="refsect1" title="INFORMATION ABOUT A PATTERN">
      <a id="pcreapi-3_sect15" name="pcreapi-3_sect15" shape="rect"> </a>

      <h2>INFORMATION ABOUT A PATTERN</h2>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int
            <strong>pcre_fullinfo</strong>(</code></td>

            <td rowspan="1" colspan="1">const pcre *<var class="pdparam">code</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const pcre_extra *<var class="pdparam">extra</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">what</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">void *<var class="pdparam">where</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <p>The <code class="function">pcre_fullinfo</code>() function
      returns information about a compiled pattern. It replaces the
      <code class="function">pcre_info</code>() function, which was
      removed from the library at version 8.30, after more than 10
      years of obsolescence.</p>

      <p>The first argument for <code class="function">pcre_fullinfo</code>() is a pointer to the
      compiled pattern. The second argument is the result of
      <code class="function">pcre_study</code>(), or NULL if the
      pattern was not studied. The third argument specifies which
      piece of information is required, and the fourth argument is
      a pointer to a variable to receive the data. The yield of the
      function is zero for success, or one of the following
      negative numbers:</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 PCRE_ERROR_NULL           the argument <em class="parameter"><code>code</code></em> was NULL
                           the argument <em class="parameter"><code>where</code></em> was NULL
 PCRE_ERROR_BADMAGIC       the "magic number" was not found
 PCRE_ERROR_BADENDIANNESS  the pattern was compiled with different
                           endianness
 PCRE_ERROR_BADOPTION      the value of <em class="parameter"><code>what</code></em> was invalid
</pre>
      </div>

      <p>The "magic number" is placed at the start of each compiled
      pattern as an simple check against passing an arbitrary
      memory pointer. The endianness error can occur if a compiled
      pattern is saved and reloaded on a different host. Here is a
      typical call of <code class="function">pcre_fullinfo</code>(), to obtain the length of
      the compiled pattern:</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 int rc;
 size_t length;
 rc = pcre_fullinfo(
   re,               /* result of pcre_compile() */
   sd,               /* result of pcre_study(), or NULL */
   PCRE_INFO_SIZE,   /* what is required */
   &amp;length);         /* where to put the data */
</pre>
      </div>

      <p>The possible values for the third argument are defined in
      <code class="filename">pcre.h</code>, and are as follows:</p>

      <div class="variablelist">
        <dl>
          <dt><span class="term"><code class="constant">PCRE_INFO_BACKREFMAX</code></span></dt>

          <dd>
            <p>Return the number of the highest back reference in
            the pattern. The fourth argument should point to an
            <span class="type">int</span> variable. Zero is
            returned if there are no back references.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_INFO_CAPTURECOUNT</code></span></dt>

          <dd>
            <p>Return the number of capturing subpatterns in the
            pattern. The fourth argument should point to an
            <span class="type">int</span> variable.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_INFO_DEFAULT_TABLES</code></span></dt>

          <dd>
            <p>Return a pointer to the internal default character
            tables within PCRE. The fourth argument should point to
            an <span class="type">unsigned char *</span> variable.
            This information call is provided for internal use by
            the <code class="function">pcre_study</code>()
            function. External callers can cause PCRE to use its
            internal tables by passing a NULL table pointer.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_INFO_FIRSTBYTE</code></span></dt>

          <dd>
            <p>Return information about the first data unit of any
            matched string, for a non-anchored pattern. (The name
            of this option refers to the 8-bit library, where data
            units are bytes.) The fourth argument should point to
            an <span class="type">int</span> variable.</p>
          </dd>
        </dl>
      </div>

      <p>If there is a fixed first value, for example, the letter
      "c" from a pattern such as (cat|cow|coyote), its value is
      returned. In the 8-bit library, the value is always less than
      256; in the 16-bit library the value can be up to 0xffff.</p>

      <p>If there is no fixed first value, and if either</p>

      <p>(a) the pattern was compiled with the PCRE_MULTILINE
      option, and every branch starts with "^", or</p>

      <p>(b) every branch of the pattern starts with ".*" and
      PCRE_DOTALL is not set (if it were set, the pattern would be
      anchored),</p>

      <p>-1 is returned, indicating that the pattern matches only
      at the start of a subject string or after any newline within
      the string. Otherwise -2 is returned. For anchored patterns,
      -2 is returned.</p>

      <div class="variablelist">
        <dl>
          <dt><span class="term"><code class="constant">PCRE_INFO_FIRSTTABLE</code></span></dt>

          <dd>
            <p>If the pattern was studied, and this resulted in the
            construction of a 256-bit table indicating a fixed set
            of values for the first data unit in any matching
            string, a pointer to the table is returned. Otherwise
            NULL is returned. The fourth argument should point to
            an <span class="type">unsigned char *</span>
            variable.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_INFO_HASCRORLF</code></span></dt>

          <dd>
            <p>Return 1 if the pattern contains any explicit
            matches for CR or LF characters, otherwise 0. The
            fourth argument should point to an <span class="type">int</span> variable. An explicit match is either
            a literal CR or LF character, or \r or \n.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_INFO_JCHANGED</code></span></dt>

          <dd>
            <p>Return 1 if the (?J) or (?-J) option setting is used
            in the pattern, otherwise 0. The fourth argument should
            point to an <span class="type">int</span> variable.
            (?J) and (?-J) set and unset the local PCRE_DUPNAMES
            option, respectively.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_INFO_JIT</code></span></dt>

          <dd>
            <p>Return 1 if the pattern was studied with one of the
            JIT options, and just-in-time compiling was successful.
            The fourth argument should point to an <span class="type">int</span> variable. A return value of 0 means
            that JIT support is not available in this version of
            PCRE, or that the pattern was not studied with a JIT
            option, or that the JIT compiler could not handle this
            particular pattern. See the <a class="link" href="../htmlman3/pcrejit.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrejit</span>(3)</span></a>
            documentation for details of what can and cannot be
            handled.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_INFO_JITSIZE</code></span></dt>

          <dd>
            <p>If the pattern was successfully studied with a JIT
            option, return the size of the JIT compiled code,
            otherwise return zero. The fourth argument should point
            to a <em class="parameter"><code>size_t</code></em>
            variable.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_INFO_LASTLITERAL</code></span></dt>

          <dd>
            <p>Return the value of the rightmost literal data unit
            that must exist in any matched string, other than at
            its start, if such a value has been recorded. The
            fourth argument should point to an <span class="type">int</span> variable. If there is no such value,
            -1 is returned. For anchored patterns, a last literal
            value is recorded only if it follows something of
            variable length. For example, for the pattern
            /^a\d+z\d+/ the returned value is "z", but for
            /^a\dz\d/ the returned value is -1.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_INFO_MAXLOOKBEHIND</code></span></dt>

          <dd>
            <p>Return the number of characters (NB not bytes) in
            the longest lookbehind assertion in the pattern. Note
            that the simple assertions \b and \B require a
            one-character lookbehind. This information is useful
            when doing multi-segment matching using the partial
            matching facilities.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_INFO_MINLENGTH</code></span></dt>

          <dd>
            <p>If the pattern was studied and a minimum length for
            matching subject strings was computed, its value is
            returned. Otherwise the returned value is -1. The value
            is a number of characters, which in UTF-8 mode may be
            different from the number of bytes. The fourth argument
            should point to an <span class="type">int</span>
            variable. A non-negative value is a lower bound to the
            length of any matching string. There may not be any
            strings of that length that do actually match, but
            every string that does match is at least that long.</p>

            <div class="informalexample">
              <pre class="programlisting" xml:space="preserve">
 PCRE_INFO_NAMECOUNT
 PCRE_INFO_NAMEENTRYSIZE
 PCRE_INFO_NAMETABLE
</pre>
            </div>

            <p>PCRE supports the use of named as well as numbered
            capturing parentheses. The names are just an additional
            way of identifying the parentheses, which still acquire
            numbers. Several convenience functions such as
            <code class="function">pcre_get_named_substring</code>() are
            provided for extracting captured substrings by name. It
            is also possible to extract the data directly, by first
            converting the name to a number in order to access the
            correct pointers in the output vector (described with
            <code class="function">pcre_exec</code>() below). To do
            the conversion, you need to use the name-to-number map,
            which is described by these three values.</p>
          </dd>
        </dl>
      </div>

      <p>The map consists of a number of fixed-size entries.
      PCRE_INFO_NAMECOUNT gives the number of entries, and
      PCRE_INFO_NAMEENTRYSIZE gives the size of each entry; both of
      these return an <span class="type">int</span> value. The
      entry size depends on the length of the longest name.
      PCRE_INFO_NAMETABLE returns a pointer to the first entry of
      the table. This is a pointer to <span class="type">char</span> in the 8-bit library, where the first two
      bytes of each entry are the number of the capturing
      parenthesis, most significant byte first. In the 16-bit
      library, the pointer points to 16-bit data units, the first
      of which contains the parenthesis number. The rest of the
      entry is the corresponding name, zero terminated.</p>

      <p>The names are in alphabetical order. Duplicate names may
      appear if (?| is used to create multiple groups with the same
      number, as described in the section on duplicate subpattern
      numbers in the <a class="link" href="../htmlman3/pcrepattern.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrepattern</span>(3)</span></a> page.
      Duplicate names for subpatterns with different numbers are
      permitted only if PCRE_DUPNAMES is set. In all cases of
      duplicate names, they appear in the table in the order in
      which they were found in the pattern. In the absence of (?|
      this is the order of increasing number; when (?| is used this
      is not necessarily the case because later subpatterns may
      have lower numbers.</p>

      <p>As a simple example of the name/number table, consider the
      following pattern after compilation by the 8-bit library
      (assume PCRE_EXTENDED is set, so white space - including
      newlines - is ignored):</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 (?&lt;date&gt; (?&lt;year&gt;(\d\d)?\d\d) -
 (?&lt;month&gt;\d\d) - (?&lt;day&gt;\d\d) )
</pre>
      </div>

      <p>There are four named subpatterns, so the table has four
      entries, and each entry in the table is eight bytes long. The
      table is as follows, with non-printing bytes shows in
      hexadecimal, and undefined bytes shown as ??:</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 00 01 d  a  t  e  00 ??
 00 05 d  a  y  00 ?? ??
 00 04 m  o  n  t  h  00
 00 02 y  e  a  r  00 ??
</pre>
      </div>

      <p>When writing code to extract data from named subpatterns
      using the name-to-number map, remember that the length of the
      entries is likely to be different for each compiled
      pattern.</p>

      <div class="variablelist">
        <dl>
          <dt><span class="term"><code class="constant">PCRE_INFO_OKPARTIAL</code></span></dt>

          <dd>
            <p>Return 1 if the pattern can be used for partial
            matching with <code class="function">pcre_exec</code>(), otherwise 0. The fourth
            argument should point to an <span class="type">int</span> variable. From release 8.00, this
            always returns 1, because the restrictions that
            previously applied to partial matching have been
            lifted. The <a class="link" href="../htmlman3/pcrepartial.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrepartial</span>(3)</span></a>
            documentation gives details of partial matching.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_INFO_OPTIONS</code></span></dt>

          <dd>
            <p>Return a copy of the options with which the pattern
            was compiled. The fourth argument should point to an
            <span class="type">unsigned long int</span> variable.
            These option bits are those specified in the call to
            <code class="function">pcre_compile</code>(), modified
            by any top-level option settings at the start of the
            pattern itself. In other words, they are the options
            that will be in force when matching starts. For
            example, if the pattern /(?im)abc(?-i)d/ is compiled
            with the PCRE_EXTENDED option, the result is
            PCRE_CASELESS, PCRE_MULTILINE, and PCRE_EXTENDED.</p>
          </dd>
        </dl>
      </div>

      <p>A pattern is automatically anchored by PCRE if all of its
      top-level alternatives begin with one of the following:</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 ^     unless PCRE_MULTILINE is set
 \A    always
 \G    always
 .*    if PCRE_DOTALL is set and there are no back
         references to the subpattern in which .* appears
</pre>
      </div>

      <p>For such patterns, the PCRE_ANCHORED bit is set in the
      options returned by <code class="function">pcre_fullinfo</code>().</p>

      <div class="variablelist">
        <dl>
          <dt><span class="term"><code class="constant">PCRE_INFO_SIZE</code></span></dt>

          <dd>
            <p>Return the size of the compiled pattern in bytes
            (for both libraries). The fourth argument should point
            to a <em class="parameter"><code>size_t</code></em>
            variable. This value does not include the size of the
            <code class="function">pcre</code> structure that is
            returned by <code class="function">pcre_compile</code>(). The value that is
            passed as the argument to <code class="function">pcre_malloc</code>() when <code class="function">pcre_compile</code>() is getting memory in
            which to place the compiled data is the value returned
            by this option plus the size of the <code class="function">pcre</code> structure. Studying a compiled
            pattern, with or without JIT, does not alter the value
            returned by this option.</p>
          </dd>

          <dt><span class="term"><code class="constant">PCRE_INFO_STUDYSIZE</code></span></dt>

          <dd>
            <p>Return the size in bytes of the data block pointed
            to by the <em class="parameter"><code>study_data</code></em> field in a
            <span class="type">pcre_extra</span> block. If
            <span class="type">pcre_extra</span> is NULL, or there
            is no study data, zero is returned. The fourth argument
            should point to a <em class="parameter"><code>size_t</code></em> variable. The
            <em class="parameter"><code>study_data</code></em>
            field is set by <code class="function">pcre_study</code>() to record information
            that will speed up matching (see the section entitled
            "Studying a pattern" above). The format of the
            <em class="parameter"><code>study_data</code></em>
            block is private, but its length is made available via
            this option so that it can be saved and restored (see
            the <a class="link" href="../htmlman3/pcreprecompile.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcreprecompile</span>(3)</span></a>
            documentation for details).</p>
          </dd>
        </dl>
      </div>
    </div>

    <div class="refsect1" title="REFERENCE COUNTS">
      <a id="pcreapi-3_sect16" name="pcreapi-3_sect16" shape="rect"> </a>

      <h2>REFERENCE COUNTS</h2>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int
            <strong>pcre_refcount</strong>(</code></td>

            <td rowspan="1" colspan="1">pcre *<var class="pdparam">code</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">adjust</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <p>The <code class="function">pcre_refcount</code>() function
      is used to maintain a reference count in the data block that
      contains a compiled pattern. It is provided for the benefit
      of applications that operate in an object-oriented manner,
      where different parts of the application may be using the
      same compiled pattern, but you want to free the block when
      they are all done.</p>

      <p>When a pattern is compiled, the reference count field is
      initialized to zero. It is changed only by calling this
      function, whose action is to add the <em class="parameter"><code>adjust</code></em> value (which may be
      positive or negative) to it. The yield of the function is the
      new value. However, the value of the count is constrained to
      lie between 0 and 65535, inclusive. If the new value is
      outside these limits, it is forced to the appropriate limit
      value.</p>

      <p>Except when it is zero, the reference count is not
      correctly preserved if a pattern is compiled on one host and
      then transferred to a host whose byte-order is different.
      (This seems a highly unlikely scenario.)</p>
    </div>

    <div class="refsect1" title="MATCHING A PATTERN: THE TRADITIONAL FUNCTION">
      <a id="pcreapi-3_sect17" name="pcreapi-3_sect17" shape="rect"> </a>

      <h2>MATCHING A PATTERN: THE TRADITIONAL FUNCTION</h2>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int
            <strong>pcre_exec</strong>(</code></td>

            <td rowspan="1" colspan="1">const pcre *<var class="pdparam">code</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const pcre_extra *<var class="pdparam">extra</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">subject</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">length</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">startoffset</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">options</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">ovector</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">ovecsize</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <p>The function <code class="function">pcre_exec</code>() is
      called to match a subject string against a compiled pattern,
      which is passed in the <em class="parameter"><code>code</code></em> argument. If the pattern
      was studied, the result of the study should be passed in the
      <em class="parameter"><code>extra</code></em> argument. You
      can call <code class="function">pcre_exec</code>() with the
      same <em class="parameter"><code>code</code></em> and
      <em class="parameter"><code>extra</code></em> arguments as
      many times as you like, in order to match different subject
      strings with the same pattern.</p>

      <p>This function is the main matching facility of the
      library, and it operates in a Perl-like manner. For
      specialist use there is also an alternative matching
      function, which is described below in the section about the
      <code class="function">pcre_dfa_exec</code>() function.</p>

      <p>In most applications, the pattern will have been compiled
      (and optionally studied) in the same process that calls
      <code class="function">pcre_exec</code>(). However, it is
      possible to save compiled patterns and study data, and then
      use them later in different processes, possibly even on
      different hosts. For a discussion about this, see the
      <a class="link" href="../htmlman3/pcreprecompile.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcreprecompile</span>(3)</span></a>
      documentation.</p>

      <p>Here is an example of a simple call to <code class="function">pcre_exec</code>():</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 int rc;
 int ovector[30];
 rc = pcre_exec(
   re,             /* result of pcre_compile() */
   NULL,           /* we didn't study the pattern */
   "some string",  /* the subject string */
   11,             /* the length of the subject string */
   0,              /* start at offset 0 in the subject */
   0,              /* default options */
   ovector,        /* vector of integers for substring information */
   30);            /* number of elements (NOT size in bytes) */
</pre>
      </div>

      <div class="refsect2" title="Extra data for pcre_exec()">
        <a id="pcreapi-3_sect18" name="pcreapi-3_sect18" shape="rect"> </a>

        <h3>Extra data for <code class="function">pcre_exec</code>()</h3>

        <p>If the <em class="parameter"><code>extra</code></em>
        argument is not NULL, it must point to a <span class="type">pcre_extra</span> data block. The <code class="function">pcre_study</code>() function returns such a
        block (when it doesn't return NULL), but you can also
        create one for yourself, and pass additional information in
        it. The <span class="type">pcre_extra</span> block contains
        the following fields (not necessarily in this order):</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
 unsigned long int <em class="parameter"><code>flags</code></em>;
 void *<em class="parameter"><code>study_data</code></em>;
 void *<code class="function">executable_jit</code>;
 unsigned long int <em class="parameter"><code>match_limit</code></em>;
 unsigned long int <em class="parameter"><code>match_limit_recursion</code></em>;
 void *<em class="parameter"><code>callout_data</code></em>;
 const unsigned char *<em class="parameter"><code>tables</code></em>;
 unsigned char **<code class="function">mark</code>;
</pre>
        </div>

        <p>In the 16-bit version of this structure, the
        <code class="function">mark</code> field has type
        "PCRE_UCHAR16 **".</p>

        <p>The <em class="parameter"><code>flags</code></em> field
        is used to specify which of the other fields are set. The
        flag bits are:</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
 PCRE_EXTRA_CALLOUT_DATA
 PCRE_EXTRA_EXECUTABLE_JIT
 PCRE_EXTRA_MARK
 PCRE_EXTRA_MATCH_LIMIT
 PCRE_EXTRA_MATCH_LIMIT_RECURSION
 PCRE_EXTRA_STUDY_DATA
 PCRE_EXTRA_TABLES
</pre>
        </div>

        <p>Other flag bits should be set to zero. The <em class="parameter"><code>study_data</code></em> field and
        sometimes the <code class="function">executable_jit</code>
        field are set in the <span class="type">pcre_extra</span>
        block that is returned by <code class="function">pcre_study</code>(), together with the
        appropriate flag bits. You should not set these yourself,
        but you may add to the block by setting other fields and
        their corresponding flag bits.</p>

        <p>The <em class="parameter"><code>match_limit</code></em>
        field provides a means of preventing PCRE from using up a
        vast amount of resources when running patterns that are not
        going to match, but which have a very large number of
        possibilities in their search trees. The classic example is
        a pattern that uses nested unlimited repeats.</p>

        <p>Internally, <code class="function">pcre_exec</code>()
        uses a function called <code class="function">match</code>(), which it calls repeatedly
        (sometimes recursively). The limit set by <em class="parameter"><code>match_limit</code></em> is imposed on the
        number of times this function is called during a match,
        which has the effect of limiting the amount of backtracking
        that can take place. For patterns that are not anchored,
        the count restarts from zero for each position in the
        subject string.</p>

        <p>When <code class="function">pcre_exec</code>() is called
        with a pattern that was successfully studied with a JIT
        option, the way that the matching is executed is entirely
        different. However, there is still the possibility of
        runaway matching that goes on for a very long time, and so
        the <em class="parameter"><code>match_limit</code></em>
        value is also used in this case (but in a different way) to
        limit how long the matching can continue.</p>

        <p>The default value for the limit can be set when PCRE is
        built; the default default is 10 million, which handles all
        but the most extreme cases. You can override the default by
        suppling <code class="function">pcre_exec</code>() with a
        <span class="type">pcre_extra</span> block in which
        <em class="parameter"><code>match_limit</code></em> is set,
        and PCRE_EXTRA_MATCH_LIMIT is set in the <em class="parameter"><code>flags</code></em> field. If the limit is
        exceeded, <code class="function">pcre_exec</code>() returns
        PCRE_ERROR_MATCHLIMIT.</p>

        <p>The <em class="parameter"><code>match_limit_recursion</code></em> field
        is similar to <em class="parameter"><code>match_limit</code></em>, but instead of
        limiting the total number of times that <code class="function">match</code>() is called, it limits the depth of
        recursion. The recursion depth is a smaller number than the
        total number of calls, because not all calls to
        <code class="function">match</code>() are recursive. This
        limit is of use only if it is set smaller than <em class="parameter"><code>match_limit</code></em>.</p>

        <p>Limiting the recursion depth limits the amount of
        machine stack that can be used, or, when PCRE has been
        compiled to use memory on the heap instead of the stack,
        the amount of heap memory that can be used. This limit is
        not relevant, and is ignored, when matching is done using
        JIT compiled code.</p>

        <p>The default value for <em class="parameter"><code>match_limit_recursion</code></em> can be
        set when PCRE is built; the default default is the same
        value as the default for <em class="parameter"><code>match_limit</code></em>. You can override
        the default by suppling <code class="function">pcre_exec</code>() with a <span class="type">pcre_extra</span> block in which <em class="parameter"><code>match_limit_recursion</code></em> is set,
        and PCRE_EXTRA_MATCH_LIMIT_RECURSION is set in the
        <em class="parameter"><code>flags</code></em> field. If the
        limit is exceeded, <code class="function">pcre_exec</code>() returns
        PCRE_ERROR_RECURSIONLIMIT.</p>

        <p>The <em class="parameter"><code>callout_data</code></em>
        field is used in conjunction with the "callout" feature,
        and is described in the <a class="link" href="../htmlman3/pcrecallout.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrecallout</span>(3)</span></a>
        documentation.</p>

        <p>The <em class="parameter"><code>tables</code></em> field
        is used to pass a character tables pointer to <code class="function">pcre_exec</code>(); this overrides the value
        that is stored with the compiled pattern. A non-NULL value
        is stored with the compiled pattern only if custom tables
        were supplied to <code class="function">pcre_compile</code>() via its <em class="parameter"><code>tableptr</code></em> argument. If NULL is
        passed to <code class="function">pcre_exec</code>() using
        this mechanism, it forces PCRE's internal tables to be
        used. This facility is helpful when re-using patterns that
        have been saved after compiling with an external set of
        tables, because the external tables might be at a different
        address when <code class="function">pcre_exec</code>() is
        called. See the <a class="link" href="../htmlman3/pcreprecompile.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcreprecompile</span>(3)</span></a>
        documentation for a discussion of saving compiled patterns
        for later use.</p>

        <p>If PCRE_EXTRA_MARK is set in the <em class="parameter"><code>flags</code></em> field, the <code class="function">mark</code> field must be set to point to a
        suitable variable. If the pattern contains any backtracking
        control verbs such as (*MARK:NAME), and the execution ends
        up with a name to pass back, a pointer to the name string
        (zero terminated) is placed in the variable pointed to by
        the <code class="function">mark</code> field. The names are
        within the compiled pattern; if you wish to retain such a
        name you must copy it before freeing the memory of a
        compiled pattern. If there is no name to pass back, the
        variable pointed to by the <code class="function">mark</code> field is set to NULL. For details of
        the backtracking control verbs, see the section entitled
        "Backtracking control" in the <a class="link" href="../htmlman3/pcrepattern.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrepattern</span>(3)</span></a>
        documentation.</p>
      </div>

      <div class="refsect2" title="Option bits for pcre_exec()">
        <a id="pcreapi-3_sect19" name="pcreapi-3_sect19" shape="rect"> </a>

        <h3>Option bits for <code class="function">pcre_exec</code>()</h3>

        <p>The unused bits of the <em class="parameter"><code>options</code></em> argument for
        <code class="function">pcre_exec</code>() must be zero. The
        only bits that may be set are PCRE_ANCHORED,
        PCRE_NEWLINE_<em class="replaceable"><code>xxx</code></em>,
        PCRE_NOTBOL, PCRE_NOTEOL, PCRE_NOTEMPTY,
        PCRE_NOTEMPTY_ATSTART, PCRE_NO_START_OPTIMIZE,
        PCRE_NO_UTF8_CHECK, PCRE_PARTIAL_HARD, and
        PCRE_PARTIAL_SOFT.</p>

        <p>If the pattern was successfully studied with one of the
        just-in-time (JIT) compile options, the only supported
        options for JIT execution are PCRE_NO_UTF8_CHECK,
        PCRE_NOTBOL, PCRE_NOTEOL, PCRE_NOTEMPTY,
        PCRE_NOTEMPTY_ATSTART, PCRE_PARTIAL_HARD, and
        PCRE_PARTIAL_SOFT. If an unsupported option is used, JIT
        execution is disabled and the normal interpretive code in
        <code class="function">pcre_exec</code>() is run.</p>

        <div class="variablelist">
          <dl>
            <dt><span class="term"><code class="constant">PCRE_ANCHORED</code></span></dt>

            <dd>
              <p>The PCRE_ANCHORED option limits <code class="function">pcre_exec</code>() to matching at the
              first matching position. If a pattern was compiled
              with PCRE_ANCHORED, or turned out to be anchored by
              virtue of its contents, it cannot be made unachored
              at matching time.</p>

              <div class="informalexample">
                <pre class="programlisting" xml:space="preserve">
 PCRE_BSR_ANYCRLF
 PCRE_BSR_UNICODE
</pre>
              </div>

              <p>These options (which are mutually exclusive)
              control what the \R escape sequence matches. The
              choice is either to match only CR, LF, or CRLF, or to
              match any Unicode newline sequence. These options
              override the choice that was made or defaulted when
              the pattern was compiled.</p>

              <div class="informalexample">
                <pre class="programlisting" xml:space="preserve">
 PCRE_NEWLINE_CR
 PCRE_NEWLINE_LF
 PCRE_NEWLINE_CRLF
 PCRE_NEWLINE_ANYCRLF
 PCRE_NEWLINE_ANY
</pre>
              </div>

              <p>These options override the newline definition that
              was chosen or defaulted when the pattern was
              compiled. For details, see the description of
              <code class="function">pcre_compile</code>() above.
              During matching, the newline choice affects the
              behaviour of the dot, circumflex, and dollar
              metacharacters. It may also alter the way the match
              position is advanced after a match failure for an
              unanchored pattern.</p>
            </dd>
          </dl>
        </div>

        <p>When PCRE_NEWLINE_CRLF, PCRE_NEWLINE_ANYCRLF, or
        PCRE_NEWLINE_ANY is set, and a match attempt for an
        unanchored pattern fails when the current position is at a
        CRLF sequence, and the pattern contains no explicit matches
        for CR or LF characters, the match position is advanced by
        two characters instead of one, in other words, to after the
        CRLF.</p>

        <p>The above rule is a compromise that makes the most
        common cases work as expected. For example, if the pattern
        is .+A (and the PCRE_DOTALL option is not set), it does not
        match the string "\r\nA" because, after failing at the
        start, it skips both the CR and the LF before retrying.
        However, the pattern [\r\n]A does match that string,
        because it contains an explicit CR or LF reference, and so
        advances only by one character after the first failure.</p>

        <p>An explicit match for CR of LF is either a literal
        appearance of one of those characters, or one of the \r or
        \n escape sequences. Implicit matches such as [^X] do not
        count, nor does \s (which includes CR and LF in the
        characters that it matches).</p>

        <p>Notwithstanding the above, anomalous effects may still
        occur when CRLF is a valid newline sequence and explicit \r
        or \n escapes appear in the pattern.</p>

        <div class="variablelist">
          <dl>
            <dt><span class="term"><code class="constant">PCRE_NOTBOL</code></span></dt>

            <dd>
              <p>This option specifies that first character of the
              subject string is not the beginning of a line, so the
              circumflex metacharacter should not match before it.
              Setting this without PCRE_MULTILINE (at compile time)
              causes circumflex never to match. This option affects
              only the behaviour of the circumflex metacharacter.
              It does not affect \A.</p>
            </dd>

            <dt><span class="term"><code class="constant">PCRE_NOTEOL</code></span></dt>

            <dd>
              <p>This option specifies that the end of the subject
              string is not the end of a line, so the dollar
              metacharacter should not match it nor (except in
              multiline mode) a newline immediately before it.
              Setting this without PCRE_MULTILINE (at compile time)
              causes dollar never to match. This option affects
              only the behaviour of the dollar metacharacter. It
              does not affect \Z or \z.</p>
            </dd>

            <dt><span class="term"><code class="constant">PCRE_NOTEMPTY</code></span></dt>

            <dd>
              <p>An empty string is not considered to be a valid
              match if this option is set. If there are
              alternatives in the pattern, they are tried. If all
              the alternatives match the empty string, the entire
              match fails. For example, if the pattern</p>

              <div class="informalexample">
                <pre class="programlisting" xml:space="preserve">
a?b?
</pre>
              </div>

              <p>is applied to a string not beginning with "a" or
              "b", it matches an empty string at the start of the
              subject. With PCRE_NOTEMPTY set, this match is not
              valid, so PCRE searches further into the string for
              occurrences of "a" or "b".</p>
            </dd>

            <dt><span class="term"><code class="constant">PCRE_NOTEMPTY_ATSTART</code></span></dt>

            <dd>
              <p>This is like PCRE_NOTEMPTY, except that an empty
              string match that is not at the start of the subject
              is permitted. If the pattern is anchored, such a
              match can occur only if the pattern contains \K.</p>
            </dd>
          </dl>
        </div>

        <p>Perl has no direct equivalent of PCRE_NOTEMPTY or
        PCRE_NOTEMPTY_ATSTART, but it does make a special case of a
        pattern match of the empty string within its <code class="function">split</code>() function, and when using the /g
        modifier. It is possible to emulate Perl's behaviour after
        matching a null string by first trying the match again at
        the same offset with PCRE_NOTEMPTY_ATSTART and
        PCRE_ANCHORED, and then if that fails, by advancing the
        starting offset (see below) and trying an ordinary match
        again. There is some code that demonstrates how to do this
        in the <span class="citerefentry"><span class="refentrytitle">pcredemo</span>(3)</span> sample program.
        In the most general case, you have to check to see if the
        newline convention recognizes CRLF as a newline, and if so,
        and the current character is CR followed by LF, advance the
        starting offset by two characters instead of one.</p>

        <div class="variablelist">
          <dl>
            <dt><span class="term"><code class="constant">PCRE_NO_START_OPTIMIZE</code></span></dt>

            <dd>
              <p>There are a number of optimizations that
              <code class="function">pcre_exec</code>() uses at the
              start of a match, in order to speed up the process.
              For example, if it is known that an unanchored match
              must start with a specific character, it searches the
              subject for that character, and fails immediately if
              it cannot find it, without actually running the main
              matching function. This means that a special item
              such as (*COMMIT) at the start of a pattern is not
              considered until after a suitable starting point for
              the match has been found. When callouts or (*MARK)
              items are in use, these "start-up" optimizations can
              cause them to be skipped if the pattern is never
              actually used. The start-up optimizations are in
              effect a pre-scan of the subject that takes place
              before the pattern is run.</p>
            </dd>
          </dl>
        </div>

        <p>The PCRE_NO_START_OPTIMIZE option disables the start-up
        optimizations, possibly causing performance to suffer, but
        ensuring that in cases where the result is "no match", the
        callouts do occur, and that items such as (*COMMIT) and
        (*MARK) are considered at every possible starting position
        in the subject string. If PCRE_NO_START_OPTIMIZE is set at
        compile time, it cannot be unset at matching time. The use
        of PCRE_NO_START_OPTIMIZE disables JIT execution; when it
        is set, matching is always done using interpretively.</p>

        <p>Setting PCRE_NO_START_OPTIMIZE can change the outcome of
        a matching operation. Consider the pattern</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
(*COMMIT)ABC
</pre>
        </div>

        <p>When this is compiled, PCRE records the fact that a
        match must start with the character "A". Suppose the
        subject string is "DEFABC". The start-up optimization scans
        along the subject, finds "A" and runs the first match
        attempt from there. The (*COMMIT) item means that the
        pattern must match the current starting position, which in
        this case, it does. However, if the same match is run with
        PCRE_NO_START_OPTIMIZE set, the initial scan along the
        subject string does not happen. The first match attempt is
        run starting from "D" and when this fails, (*COMMIT)
        prevents any further matches being tried, so the overall
        result is "no match". If the pattern is studied, more
        start-up optimizations may be used. For example, a minimum
        length for the subject may be recorded. Consider the
        pattern</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
(*MARK:A)(X|Y)
</pre>
        </div>

        <p>The minimum length for a match is one character. If the
        subject is "ABC", there will be attempts to match "ABC",
        "BC", "C", and then finally an empty string. If the pattern
        is studied, the final attempt does not take place, because
        PCRE knows that the subject is too short, and so the
        (*MARK) is never encountered. In this case, studying the
        pattern does not affect the overall match result, which is
        still "no match", but it does affect the auxiliary
        information that is returned.</p>

        <div class="variablelist">
          <dl>
            <dt><span class="term"><code class="constant">PCRE_NO_UTF8_CHECK</code></span></dt>

            <dd>
              <p>When PCRE_UTF8 is set at compile time, the
              validity of the subject as a UTF-8 string is
              automatically checked when <code class="function">pcre_exec</code>() is subsequently called.
              The entire string is checked before any other
              processing takes place. The value of <em class="parameter"><code>startoffset</code></em> is also
              checked to ensure that it points to the start of a
              UTF-8 character. There is a discussion about the
              validity of UTF-8 strings in the <a class="link" href="../htmlman3/pcreunicode.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcreunicode</span>(3)</span></a>
              page. If an invalid sequence of bytes is found,
              <code class="function">pcre_exec</code>() returns the
              error PCRE_ERROR_BADUTF8 or, if PCRE_PARTIAL_HARD is
              set and the problem is a truncated character at the
              end of the subject, PCRE_ERROR_SHORTUTF8. In both
              cases, information about the precise nature of the
              error may also be returned (see the descriptions of
              these errors in the section entitled <span class="emphasis"><em>Error return values from</em></span>
              <code class="function">pcre_exec</code>() below). If
              <em class="parameter"><code>startoffset</code></em>
              contains a value that does not point to the start of
              a UTF-8 character (or to the end of the subject),
              PCRE_ERROR_BADUTF8_OFFSET is returned.</p>
            </dd>
          </dl>
        </div>

        <p>If you already know that your subject is valid, and you
        want to skip these checks for performance reasons, you can
        set the PCRE_NO_UTF8_CHECK option when calling <code class="function">pcre_exec</code>(). You might want to do this
        for the second and subsequent calls to <code class="function">pcre_exec</code>() if you are making repeated
        calls to find all the matches in a single subject string.
        However, you should be sure that the value of <em class="parameter"><code>startoffset</code></em> points to the
        start of a character (or the end of the subject). When
        PCRE_NO_UTF8_CHECK is set, the effect of passing an invalid
        string as a subject or an invalid value of <em class="parameter"><code>startoffset</code></em> is undefined.
        Your program may crash.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
 PCRE_PARTIAL_HARD
 PCRE_PARTIAL_SOFT
</pre>
        </div>

        <p>These options turn on the partial matching feature. For
        backwards compatibility, PCRE_PARTIAL is a synonym for
        PCRE_PARTIAL_SOFT. A partial match occurs if the end of the
        subject string is reached successfully, but there are not
        enough subject characters to complete the match. If this
        happens when PCRE_PARTIAL_SOFT (but not PCRE_PARTIAL_HARD)
        is set, matching continues by testing any remaining
        alternatives. Only if no complete match can be found is
        PCRE_ERROR_PARTIAL returned instead of PCRE_ERROR_NOMATCH.
        In other words, PCRE_PARTIAL_SOFT says that the caller is
        prepared to handle a partial match, but only if no complete
        match can be found.</p>

        <p>If PCRE_PARTIAL_HARD is set, it overrides
        PCRE_PARTIAL_SOFT. In this case, if a partial match is
        found, <code class="function">pcre_exec</code>()
        immediately returns PCRE_ERROR_PARTIAL, without considering
        any other alternatives. In other words, when
        PCRE_PARTIAL_HARD is set, a partial match is considered to
        be more important that an alternative complete match.</p>

        <p>In both cases, the portion of the string that was
        inspected when the partial match was found is set as the
        first matching string. There is a more detailed discussion
        of partial and multi-segment matching, with examples, in
        the <a class="link" href="../htmlman3/pcrepartial.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrepartial</span>(3)</span></a>
        documentation.</p>
      </div>

      <div class="refsect2" title="The string to be matched by pcre_exec()">
        <a id="pcreapi-3_sect20" name="pcreapi-3_sect20" shape="rect"> </a>

        <h3>The string to be matched by <code class="function">pcre_exec</code>()</h3>

        <p>The subject string is passed to <code class="function">pcre_exec</code>() as a pointer in <em class="parameter"><code>subject</code></em>, a length in bytes in
        <em class="parameter"><code>length</code></em>, and a
        starting byte offset in <em class="parameter"><code>startoffset</code></em>. If this is
        negative or greater than the length of the subject,
        <code class="function">pcre_exec</code>() returns
        PCRE_ERROR_BADOFFSET. When the starting offset is zero, the
        search for a match starts at the beginning of the subject,
        and this is by far the most common case. In UTF-8 mode, the
        byte offset must point to the start of a UTF-8 character
        (or the end of the subject). Unlike the pattern string, the
        subject may contain binary zero bytes.</p>

        <p>A non-zero starting offset is useful when searching for
        another match in the same subject by calling <code class="function">pcre_exec</code>() again after a previous
        success. Setting <em class="parameter"><code>startoffset</code></em> differs from just
        passing over a shortened string and setting PCRE_NOTBOL in
        the case of a pattern that begins with any kind of
        lookbehind. For example, consider the pattern</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
\Biss\B
</pre>
        </div>

        <p>which finds occurrences of "iss" in the middle of words.
        (\B matches only if the current position in the subject is
        not a word boundary.) When applied to the string
        "Mississipi" the first call to <code class="function">pcre_exec</code>() finds the first occurrence.
        If <code class="function">pcre_exec</code>() is called
        again with just the remainder of the subject, namely
        "issipi", it does not match, because \B is always false at
        the start of the subject, which is deemed to be a word
        boundary. However, if <code class="function">pcre_exec</code>() is passed the entire string
        again, but with <em class="parameter"><code>startoffset</code></em> set to 4, it
        finds the second occurrence of "iss" because it is able to
        look behind the starting point to discover that it is
        preceded by a letter.</p>

        <p>Finding all the matches in a subject is tricky when the
        pattern can match an empty string. It is possible to
        emulate Perl's /g behaviour by first trying the match again
        at the same offset, with the PCRE_NOTEMPTY_ATSTART and
        PCRE_ANCHORED options, and then if that fails, advancing
        the starting offset and trying an ordinary match again.
        There is some code that demonstrates how to do this in the
        <span class="citerefentry"><span class="refentrytitle">pcredemo</span>(3)</span> sample program.
        In the most general case, you have to check to see if the
        newline convention recognizes CRLF as a newline, and if so,
        and the current character is CR followed by LF, advance the
        starting offset by two characters instead of one.</p>

        <p>If a non-zero starting offset is passed when the pattern
        is anchored, one attempt to match at the given offset is
        made. This can only succeed if the pattern does not require
        the match to be at the start of the subject.</p>
      </div>

      <div class="refsect2" title="How pcre_exec() returns captured substrings">
        <a id="pcreapi-3_sect21" name="pcreapi-3_sect21" shape="rect"> </a>

        <h3>How <code class="function">pcre_exec</code>() returns
        captured substrings</h3>

        <p>In general, a pattern matches a certain portion of the
        subject, and in addition, further substrings from the
        subject may be picked out by parts of the pattern.
        Following the usage in Jeffrey Friedl's book, this is
        called "capturing" in what follows, and the phrase
        "capturing subpattern" is used for a fragment of a pattern
        that picks out a substring. PCRE supports several other
        kinds of parenthesized subpattern that do not cause
        substrings to be captured.</p>

        <p>Captured substrings are returned to the caller via a
        vector of integers whose address is passed in <em class="parameter"><code>ovector</code></em>. The number of
        elements in the vector is passed in <em class="parameter"><code>ovecsize</code></em>, which must be a
        non-negative number. <code class="function">Note</code>:
        this argument is NOT the size of <em class="parameter"><code>ovector</code></em> in bytes.</p>

        <p>The first two-thirds of the vector is used to pass back
        captured substrings, each substring using a pair of
        integers. The remaining third of the vector is used as
        workspace by <code class="function">pcre_exec</code>()
        while matching capturing subpatterns, and is not available
        for passing back information. The number passed in
        <em class="parameter"><code>ovecsize</code></em> should
        always be a multiple of three. If it is not, it is rounded
        down.</p>

        <p>When a match is successful, information about captured
        substrings is returned in pairs of integers, starting at
        the beginning of <em class="parameter"><code>ovector</code></em>, and continuing up to
        two-thirds of its length at the most. The first element of
        each pair is set to the byte offset of the first character
        in a substring, and the second is set to the byte offset of
        the first character after the end of a substring.
        <code class="function">Note</code>: these values are always
        byte offsets, even in UTF-8 mode. They are not character
        counts.</p>

        <p>The first pair of integers, <em class="replaceable"><code>ovector[0]</code></em> and <em class="replaceable"><code>ovector[1]</code></em>, identify the
        portion of the subject string matched by the entire
        pattern. The next pair is used for the first capturing
        subpattern, and so on. The value returned by <code class="function">pcre_exec</code>() is one more than the highest
        numbered pair that has been set. For example, if two
        substrings have been captured, the returned value is 3. If
        there are no capturing subpatterns, the return value from a
        successful match is 1, indicating that just the first pair
        of offsets has been set.</p>

        <p>If a capturing subpattern is matched repeatedly, it is
        the last portion of the string that it matched that is
        returned.</p>

        <p>If the vector is too small to hold all the captured
        substring offsets, it is used as far as possible (up to
        two-thirds of its length), and the function returns a value
        of zero. If neither the actual string matched nor any
        captured substrings are of interest, <code class="function">pcre_exec</code>() may be called with <em class="parameter"><code>ovector</code></em> passed as NULL and
        <em class="parameter"><code>ovecsize</code></em> as zero.
        However, if the pattern contains back references and the
        <em class="parameter"><code>ovector</code></em> is not big
        enough to remember the related substrings, PCRE has to get
        additional memory for use during matching. Thus it is
        usually advisable to supply an <em class="parameter"><code>ovector</code></em> of reasonable
        size.</p>

        <p>There are some cases where zero is returned (indicating
        vector overflow) when in fact the vector is exactly the
        right size for the final match. For example, consider the
        pattern</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
(a)(?:(b)c|bd)
</pre>
        </div>

        <p>If a vector of 6 elements (allowing for only 1 captured
        substring) is given with subject string "abd", <code class="function">pcre_exec</code>() will try to set the second
        captured string, thereby recording a vector overflow,
        before failing to match "c" and backing up to try the
        second alternative. The zero return, however, does
        correctly indicate that the maximum number of slots (namely
        2) have been filled. In similar cases where there is
        temporary overflow, but the final number of used slots is
        actually less than the maximum, a non-zero value is
        returned.</p>

        <p>The <code class="function">pcre_fullinfo</code>()
        function can be used to find out how many capturing
        subpatterns there are in a compiled pattern. The smallest
        size for <em class="parameter"><code>ovector</code></em>
        that will allow for <code class="literal">n</code> captured
        substrings, in addition to the offsets of the substring
        matched by the whole pattern, is (<code class="literal">n</code>+1)*3.</p>

        <p>It is possible for capturing subpattern number
        <em class="replaceable"><code>n+1</code></em> to match some
        part of the subject when subpattern <code class="literal">n</code> has not been used at all. For example,
        if the string "abc" is matched against the pattern
        (a|(z))(bc) the return from the function is 4, and
        subpatterns 1 and 3 are matched, but 2 is not. When this
        happens, both values in the offset pairs corresponding to
        unused subpatterns are set to -1.</p>

        <p>Offset values that correspond to unused subpatterns at
        the end of the expression are also set to -1. For example,
        if the string "abc" is matched against the pattern
        (abc)(x(yz)?)? subpatterns 2 and 3 are not matched. The
        return from the function is 2, because the highest used
        capturing subpattern number is 1, and the offsets for for
        the second and third capturing subpatterns (assuming the
        vector is large enough, of course) are set to -1.</p>

        <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;">
          <table border="0" summary="Note">
            <tr>
              <td rowspan="2" align="center" valign="top" width="25" colspan="1"><img alt="[Note]" src="../stylesheet/note.png" /></td>

              <th align="left" rowspan="1" colspan="1">Note</th>
            </tr>

            <tr>
              <td align="left" valign="top" rowspan="1" colspan="1">
                <p>Elements in the first two-thirds of <em class="parameter"><code>ovector</code></em> that do not
                correspond to capturing parentheses in the pattern
                are never changed. That is, if a pattern contains
                <code class="literal">n</code> capturing
                parentheses, no more than <em class="replaceable"><code>ovector[0]</code></em> to
                <em class="replaceable"><code>ovector[2n+1]</code></em> are
                set by <code class="function">pcre_exec</code>().
                The other elements (in the first two-thirds) retain
                whatever values they previously had.</p>
              </td>
            </tr>
          </table>
        </div>

        <p>Some convenience functions are provided for extracting
        the captured substrings as separate strings. These are
        described below.</p>
      </div>

      <div class="refsect2" title="Error return values from pcre_exec()">
        <a id="pcreapi-3_sect22" name="pcreapi-3_sect22" shape="rect"> </a>

        <h3>Error return values from <code class="function">pcre_exec</code>()</h3>

        <p>If <code class="function">pcre_exec</code>() fails, it
        returns a negative number. The following are defined in the
        header file:</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_NOMATCH        (-1)
</pre>
        </div>

        <p>The subject string did not match the pattern.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_NULL           (-2)
</pre>
        </div>

        <p>Either <em class="parameter"><code>code</code></em> or
        <em class="parameter"><code>subject</code></em> was passed
        as NULL, or <em class="parameter"><code>ovector</code></em>
        was NULL and <em class="parameter"><code>ovecsize</code></em> was not zero.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_BADOPTION      (-3)
</pre>
        </div>

        <p>An unrecognized bit was set in the <em class="parameter"><code>options</code></em> argument.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_BADMAGIC       (-4)
</pre>
        </div>

        <p>PCRE stores a 4-byte "magic number" at the start of the
        compiled code, to catch the case when it is passed a junk
        pointer and to detect when a pattern that was compiled in
        an environment of one endianness is run in an environment
        with the other endianness. This is the error that PCRE
        gives when the magic number is not present.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_UNKNOWN_OPCODE (-5)
</pre>
        </div>

        <p>While running the pattern match, an unknown item was
        encountered in the compiled pattern. This error could be
        caused by a bug in PCRE or by overwriting of the compiled
        pattern.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_NOMEMORY       (-6)
</pre>
        </div>

        <p>If a pattern contains back references, but the
        <em class="parameter"><code>ovector</code></em> that is
        passed to <code class="function">pcre_exec</code>() is not
        big enough to remember the referenced substrings, PCRE gets
        a block of memory at the start of matching to use for this
        purpose. If the call via <code class="function">pcre_malloc</code>() fails, this error is given.
        The memory is automatically freed at the end of
        matching.</p>

        <p>This error is also given if <code class="function">pcre_stack_malloc</code>() fails in <code class="function">pcre_exec</code>(). This can happen only when
        PCRE has been compiled with <code class="option">−−disable−stack−for−recursion</code>.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_NOSUBSTRING    (-7)
</pre>
        </div>

        <p>This error is used by the <code class="function">pcre_copy_substring</code>(), <code class="function">pcre_get_substring</code>(), and <code class="function">pcre_get_substring_list</code>() functions (see
        below). It is never returned by <code class="function">pcre_exec</code>().</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_MATCHLIMIT     (-8)
</pre>
        </div>

        <p>The backtracking limit, as specified by the <em class="parameter"><code>match_limit</code></em> field in a
        <span class="type">pcre_extra</span> structure (or
        defaulted) was reached. See the description above.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_CALLOUT        (-9)
</pre>
        </div>

        <p>This error is never generated by <code class="function">pcre_exec</code>() itself. It is provided for
        use by callout functions that want to yield a distinctive
        error code. See the <a class="link" href="../htmlman3/pcrecallout.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrecallout</span>(3)</span></a>
        documentation for details.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_BADUTF8        (-10)
</pre>
        </div>

        <p>A string that contains an invalid UTF-8 byte sequence
        was passed as a subject, and the PCRE_NO_UTF8_CHECK option
        was not set. If the size of the output vector (<em class="parameter"><code>ovecsize</code></em>) is at least 2, the
        byte offset to the start of the the invalid UTF-8 character
        is placed in the first element, and a reason code is placed
        in the second element. The reason codes are listed in the
        following section. For backward compatibility, if
        PCRE_PARTIAL_HARD is set and the problem is a truncated
        UTF-8 character at the end of the subject (reason codes 1
        to 5), PCRE_ERROR_SHORTUTF8 is returned instead of
        PCRE_ERROR_BADUTF8.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_BADUTF8_OFFSET (-11)
</pre>
        </div>

        <p>The UTF-8 byte sequence that was passed as a subject was
        checked and found to be valid (the PCRE_NO_UTF8_CHECK
        option was not set), but the value of <em class="parameter"><code>startoffset</code></em> did not point to
        the beginning of a UTF-8 character or the end of the
        subject.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_PARTIAL        (-12)
</pre>
        </div>

        <p>The subject string did not match, but it did match
        partially. See the <a class="link" href="../htmlman3/pcrepartial.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrepartial</span>(3)</span></a>
        documentation for details of partial matching.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_BADPARTIAL     (-13)
</pre>
        </div>

        <p>This code is no longer in use. It was formerly returned
        when the PCRE_PARTIAL option was used with a compiled
        pattern containing items that were not supported for
        partial matching. From release 8.00 onwards, there are no
        restrictions on partial matching.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_INTERNAL       (-14)
</pre>
        </div>

        <p>An unexpected internal error has occurred. This error
        could be caused by a bug in PCRE or by overwriting of the
        compiled pattern.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_BADCOUNT       (-15)
</pre>
        </div>

        <p>This error is given if the value of the <em class="parameter"><code>ovecsize</code></em> argument is
        negative.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_RECURSIONLIMIT (-21)
</pre>
        </div>

        <p>The internal recursion limit, as specified by the
        <em class="parameter"><code>match_limit_recursion</code></em> field
        in a <span class="type">pcre_extra</span> structure (or
        defaulted) was reached. See the description above.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_BADNEWLINE     (-23)
</pre>
        </div>

        <p>An invalid combination of PCRE_NEWLINE_<em class="replaceable"><code>xxx</code></em> options was given.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_BADOFFSET      (-24)
</pre>
        </div>

        <p>The value of <em class="parameter"><code>startoffset</code></em> was negative or
        greater than the length of the subject, that is, the value
        in <em class="parameter"><code>length</code></em>.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_SHORTUTF8      (-25)
</pre>
        </div>

        <p>This error is returned instead of PCRE_ERROR_BADUTF8
        when the subject string ends with a truncated UTF-8
        character and the PCRE_PARTIAL_HARD option is set.
        Information about the failure is returned as for
        PCRE_ERROR_BADUTF8. It is in fact sufficient to detect this
        case, but this special error code for PCRE_PARTIAL_HARD
        precedes the implementation of returned information; it is
        retained for backwards compatibility.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_RECURSELOOP    (-26)
</pre>
        </div>

        <p>This error is returned when <code class="function">pcre_exec</code>() detects a recursion loop
        within the pattern. Specifically, it means that either the
        whole pattern or a subpattern has been called recursively
        for the second time at the same position in the subject
        string. Some simple patterns that might do this are
        detected and faulted at compile time, but more complicated
        cases, in particular mutual recursions between two
        different subpatterns, cannot be detected until run
        time.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_JIT_STACKLIMIT (-27)
</pre>
        </div>

        <p>This error is returned when a pattern that was
        successfully studied using a JIT compile option is being
        matched, but the memory available for the just-in-time
        processing stack is not large enough. See the <a class="link" href="../htmlman3/pcrejit.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrejit</span>(3)</span></a> documentation
        for more details.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_BADMODE        (-28)
</pre>
        </div>

        <p>This error is given if a pattern that was compiled by
        the 8-bit library is passed to a 16-bit library function,
        or vice versa.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_BADENDIANNESS  (-29)
</pre>
        </div>

        <p>This error is given if a pattern that was compiled and
        saved is reloaded on a host with different endianness. The
        utility function <code class="function">pcre_pattern_to_host_byte_order</code>() can be
        used to convert such a pattern so that it runs on the new
        host.</p>

        <p>Error numbers -16 to -20, -22, and -30 are not used by
        <code class="function">pcre_exec</code>().</p>
      </div>

      <div class="refsect2" title="Reason codes for invalid UTF-8 strings">
        <a id="pcreapi-3_sect23" name="pcreapi-3_sect23" shape="rect"> </a>

        <h3>Reason codes for invalid UTF-8 strings</h3>

        <p>This section applies only to the 8-bit library. The
        corresponding information for the 16-bit library is given
        in the <a class="link" href="../htmlman3/pcre16.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre16</span>(3)</span></a> page.</p>

        <p>When <code class="function">pcre_exec</code>() returns
        either PCRE_ERROR_BADUTF8 or PCRE_ERROR_SHORTUTF8, and the
        size of the output vector (<em class="parameter"><code>ovecsize</code></em>) is at least 2, the
        offset of the start of the invalid UTF-8 character is
        placed in the first output vector element (<em class="replaceable"><code>ovector[0]</code></em>) and a reason
        code is placed in the second element (<em class="replaceable"><code>ovector[1]</code></em>). The reason
        codes are given names in the <code class="filename">pcre.h</code> header file:</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
 PCRE_UTF8_ERR1
 PCRE_UTF8_ERR2
 PCRE_UTF8_ERR3
 PCRE_UTF8_ERR4
 PCRE_UTF8_ERR5
</pre>
        </div>

        <p>The string ends with a truncated UTF-8 character; the
        code specifies how many bytes are missing (1 to 5).
        Although RFC 3629 restricts UTF-8 characters to be no
        longer than 4 bytes, the encoding scheme (originally
        defined by RFC 2279) allows for up to 6 bytes, and this is
        checked first; hence the possibility of 4 or 5 missing
        bytes.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
 PCRE_UTF8_ERR6
 PCRE_UTF8_ERR7
 PCRE_UTF8_ERR8
 PCRE_UTF8_ERR9
 PCRE_UTF8_ERR10
</pre>
        </div>

        <p>The two most significant bits of the 2nd, 3rd, 4th, 5th,
        or 6th byte of the character do not have the binary value
        0b10 (that is, either the most significant bit is 0, or the
        next bit is 1).</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
 PCRE_UTF8_ERR11
 PCRE_UTF8_ERR12
</pre>
        </div>

        <p>A character that is valid by the RFC 2279 rules is
        either 5 or 6 bytes long; these code points are excluded by
        RFC 3629.</p>

        <div class="variablelist">
          <dl>
            <dt><span class="term"><code class="constant">PCRE_UTF8_ERR13</code></span></dt>

            <dd>
              <p>A 4-byte character has a value greater than
              0x10fff; these code points are excluded by RFC
              3629.</p>
            </dd>

            <dt><span class="term"><code class="constant">PCRE_UTF8_ERR14</code></span></dt>

            <dd>
              <p>A 3-byte character has a value in the range 0xd800
              to 0xdfff; this range of code points are reserved by
              RFC 3629 for use with UTF-16, and so are excluded
              from UTF-8.</p>

              <div class="informalexample">
                <pre class="programlisting" xml:space="preserve">
 PCRE_UTF8_ERR15
 PCRE_UTF8_ERR16
 PCRE_UTF8_ERR17
 PCRE_UTF8_ERR18
 PCRE_UTF8_ERR19
</pre>
              </div>

              <p>A 2-, 3-, 4-, 5-, or 6-byte character is
              "overlong", that is, it codes for a value that can be
              represented by fewer bytes, which is invalid. For
              example, the two bytes 0xc0, 0xae give the value
              0x2e, whose correct coding uses just one byte.</p>
            </dd>

            <dt><span class="term"><code class="constant">PCRE_UTF8_ERR20</code></span></dt>

            <dd>
              <p>The two most significant bits of the first byte of
              a character have the binary value 0b10 (that is, the
              most significant bit is 1 and the second is 0). Such
              a byte can only validly occur as the second or
              subsequent byte of a multi-byte character.</p>
            </dd>

            <dt><span class="term"><code class="constant">PCRE_UTF8_ERR21</code></span></dt>

            <dd>
              <p>The first byte of a character has the value 0xfe
              or 0xff. These values can never occur in a valid
              UTF-8 string.</p>
            </dd>
          </dl>
        </div>
      </div>
    </div>

    <div class="refsect1" title="EXTRACTING CAPTURED SUBSTRINGS BY NUMBER">
      <a id="pcreapi-3_sect24" name="pcreapi-3_sect24" shape="rect"> </a>

      <h2>EXTRACTING CAPTURED SUBSTRINGS BY NUMBER</h2>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int
            <strong>pcre_copy_substring</strong>(</code></td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">subject</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">ovector</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">stringcount</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">stringnumber</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">char *<var class="pdparam">buffer</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">buffersize</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int
            <strong>pcre_get_substring</strong>(</code></td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">subject</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">ovector</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">stringcount</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">stringnumber</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char **<var class="pdparam">stringptr</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int
            <strong>pcre_get_substring_list</strong>(</code></td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">subject</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">ovector</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">stringcount</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char ***<var class="pdparam">listptr</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <p>Captured substrings can be accessed directly by using the
      offsets returned by <code class="function">pcre_exec</code>()
      in <em class="parameter"><code>ovector</code></em>. For
      convenience, the functions <code class="function">pcre_copy_substring</code>(), <code class="function">pcre_get_substring</code>(), and <code class="function">pcre_get_substring_list</code>() are provided for
      extracting captured substrings as new, separate,
      zero-terminated strings. These functions identify substrings
      by number. The next section describes functions for
      extracting named substrings.</p>

      <p>A substring that contains a binary zero is correctly
      extracted and has a further zero added on the end, but the
      result is not, of course, a C string. However, you can
      process such a string by referring to the length that is
      returned by <code class="function">pcre_copy_substring</code>() and <code class="function">pcre_get_substring</code>(). Unfortunately, the
      interface to <code class="function">pcre_get_substring_list</code>() is not adequate
      for handling strings containing binary zeros, because the end
      of the final string is not independently indicated.</p>

      <p>The first three arguments are the same for all three of
      these functions: <em class="parameter"><code>subject</code></em> is the subject string
      that has just been successfully matched, <em class="parameter"><code>ovector</code></em> is a pointer to the
      vector of integer offsets that was passed to <code class="function">pcre_exec</code>(), and <em class="parameter"><code>stringcount</code></em> is the number of
      substrings that were captured by the match, including the
      substring that matched the entire regular expression. This is
      the value returned by <code class="function">pcre_exec</code>() if it is greater than zero. If
      <code class="function">pcre_exec</code>() returned zero,
      indicating that it ran out of space in <em class="parameter"><code>ovector</code></em>, the value passed as
      <em class="parameter"><code>stringcount</code></em> should be
      the number of elements in the vector divided by three.</p>

      <p>The functions <code class="function">pcre_copy_substring</code>() and <code class="function">pcre_get_substring</code>() extract a single
      substring, whose number is given as <em class="parameter"><code>stringnumber</code></em>. A value of zero
      extracts the substring that matched the entire pattern,
      whereas higher values extract the captured substrings. For
      <code class="function">pcre_copy_substring</code>(), the
      string is placed in <em class="parameter"><code>buffer</code></em>, whose length is given
      by <em class="parameter"><code>buffersize</code></em>, while
      for <code class="function">pcre_get_substring</code>() a new
      block of memory is obtained via <code class="function">pcre_malloc</code>, and its address is returned
      via <em class="parameter"><code>stringptr</code></em>. The
      yield of the function is the length of the string, not
      including the terminating zero, or one of these error
      codes:</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_NOMEMORY       (-6)
</pre>
      </div>

      <p>The buffer was too small for <code class="function">pcre_copy_substring</code>(), or the attempt to
      get memory failed for <code class="function">pcre_get_substring</code>().</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_NOSUBSTRING    (-7)
</pre>
      </div>

      <p>There is no substring whose number is <em class="parameter"><code>stringnumber</code></em>.</p>

      <p>The <code class="function">pcre_get_substring_list</code>() function extracts
      all available substrings and builds a list of pointers to
      them. All this is done in a single block of memory that is
      obtained via <code class="function">pcre_malloc</code>. The
      address of the memory block is returned via <em class="parameter"><code>listptr</code></em>, which is also the
      start of the list of string pointers. The end of the list is
      marked by a NULL pointer. The yield of the function is zero
      if all went well, or the error code</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_NOMEMORY       (-6)
</pre>
      </div>

      <p>if the attempt to get the memory block failed.</p>

      <p>When any of these functions encounter a substring that is
      unset, which can happen when capturing subpattern number
      <em class="replaceable"><code>n+1</code></em> matches some
      part of the subject, but subpattern <code class="literal">n</code> has not been used at all, they return an
      empty string. This can be distinguished from a genuine
      zero-length substring by inspecting the appropriate offset in
      <em class="parameter"><code>ovector</code></em>, which is
      negative for unset substrings.</p>

      <p>The two convenience functions <code class="function">pcre_free_substring</code>() and <code class="function">pcre_free_substring_list</code>() can be used to
      free the memory returned by a previous call of <code class="function">pcre_get_substring</code>() or <code class="function">pcre_get_substring_list</code>(), respectively.
      They do nothing more than call the function pointed to by
      <code class="function">pcre_free</code>, which of course
      could be called directly from a C program. However, PCRE is
      used in some situations where it is linked via a special
      interface to another programming language that cannot use
      <code class="function">pcre_free</code> directly; it is for
      these cases that the functions are provided.</p>
    </div>

    <div class="refsect1" title="EXTRACTING CAPTURED SUBSTRINGS BY NAME">
      <a id="pcreapi-3_sect25" name="pcreapi-3_sect25" shape="rect"> </a>

      <h2>EXTRACTING CAPTURED SUBSTRINGS BY NAME</h2>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int
            <strong>pcre_get_stringnumber</strong>(</code></td>

            <td rowspan="1" colspan="1">const pcre *<var class="pdparam">code</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">name</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int
            <strong>pcre_copy_named_substring</strong>(</code></td>

            <td rowspan="1" colspan="1">const pcre *<var class="pdparam">code</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">subject</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">ovector</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">stringcount</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">stringname</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">char *<var class="pdparam">buffer</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">buffersize</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int
            <strong>pcre_get_named_substring</strong>(</code></td>

            <td rowspan="1" colspan="1">const pcre *<var class="pdparam">code</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">subject</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">ovector</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">stringcount</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">stringname</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char **<var class="pdparam">stringptr</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <p>To extract a substring by name, you first have to find
      associated number. For example, for this pattern</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
(a+)b(?&lt;xxx&gt;\d+)...
</pre>
      </div>

      <p>the number of the subpattern called "xxx" is 2. If the
      name is known to be unique (PCRE_DUPNAMES was not set), you
      can find the number from the name by calling <code class="function">pcre_get_stringnumber</code>(). The first argument
      is the compiled pattern, and the second is the name. The
      yield of the function is the subpattern number, or
      PCRE_ERROR_NOSUBSTRING (-7) if there is no subpattern of that
      name.</p>

      <p>Given the number, you can extract the substring directly,
      or use one of the functions described in the previous
      section. For convenience, there are also two functions that
      do the whole job.</p>

      <p>Most of the arguments of <code class="function">pcre_copy_named_substring</code>() and
      <code class="function">pcre_get_named_substring</code>() are
      the same as those for the similarly named functions that
      extract by number. As these are described in the previous
      section, they are not re-described here. There are just two
      differences:</p>

      <p>First, instead of a substring number, a substring name is
      given. Second, there is an extra argument, given at the
      start, which is a pointer to the compiled pattern. This is
      needed in order to gain access to the name-to-number
      translation table.</p>

      <p>These functions call <code class="function">pcre_get_stringnumber</code>(), and if it
      succeeds, they then call <code class="function">pcre_copy_substring</code>() or <code class="function">pcre_get_substring</code>(), as appropriate.
      <em class="replaceable"><code>NOTE:</code></em> If
      PCRE_DUPNAMES is set and there are duplicate names, the
      behaviour may not be what you want (see the next
      section).</p>

      <div class="warning" title="Warning" style="margin-left: 0.5in; margin-right: 0.5in;">
        <table border="0" summary="Warning">
          <tr>
            <td rowspan="2" align="center" valign="top" width="25" colspan="1">
            <img alt="[Warning]" src="../stylesheet/warning.png" /></td>

            <th align="left" rowspan="1" colspan="1">Warning</th>
          </tr>

          <tr>
            <td align="left" valign="top" rowspan="1" colspan="1">
              <p>If the pattern uses the (?| feature to set up
              multiple subpatterns with the same number, as
              described in the section on duplicate subpattern
              numbers in the <a class="link" href="../htmlman3/pcrepattern.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrepattern</span>(3)</span></a>
              page, you cannot use names to distinguish the
              different subpatterns, because names are not included
              in the compiled code. The matching process uses only
              numbers. For this reason, the use of different names
              for subpatterns of the same number causes an error at
              compile time.</p>
            </td>
          </tr>
        </table>
      </div>
    </div>

    <div class="refsect1" title="DUPLICATE SUBPATTERN NAMES">
      <a id="pcreapi-3_sect26" name="pcreapi-3_sect26" shape="rect"> </a>

      <h2>DUPLICATE SUBPATTERN NAMES</h2>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int
            <strong>pcre_get_stringtable_entries</strong>(</code></td>

            <td rowspan="1" colspan="1">const pcre *<var class="pdparam">code</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">name</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">char **<var class="pdparam">first</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">char **<var class="pdparam">last</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <p>When a pattern is compiled with the PCRE_DUPNAMES option,
      names for subpatterns are not required to be unique.
      (Duplicate names are always allowed for subpatterns with the
      same number, created by using the (?| feature. Indeed, if
      such subpatterns are named, they are required to use the same
      names.)</p>

      <p>Normally, patterns with duplicate names are such that in
      any one match, only one of the named subpatterns
      participates. An example is shown in the <a class="link" href="../htmlman3/pcrepattern.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrepattern</span>(3)</span></a>
      documentation.</p>

      <p>When duplicates are present, <code class="function">pcre_copy_named_substring</code>() and
      <code class="function">pcre_get_named_substring</code>()
      return the first substring corresponding to the given name
      that is set. If none are set, PCRE_ERROR_NOSUBSTRING (-7) is
      returned; no data is returned. The <code class="function">pcre_get_stringnumber</code>() function returns
      one of the numbers that are associated with the name, but it
      is not defined which it is.</p>

      <p>If you want to get full details of all captured substrings
      for a given name, you must use the <code class="function">pcre_get_stringtable_entries</code>() function.
      The first argument is the compiled pattern, and the second is
      the name. The third and fourth are pointers to variables
      which are updated by the function. After it has run, they
      point to the first and last entries in the name-to-number
      table for the given name. The function itself returns the
      length of each entry, or PCRE_ERROR_NOSUBSTRING (-7) if there
      are none. The format of the table is described above in the
      section entitled <span class="emphasis"><em>Information about
      a pattern</em></span> above. Given all the relevant entries
      for the name, you can extract each of their numbers, and
      hence the captured data, if any.</p>
    </div>

    <div class="refsect1" title="FINDING ALL POSSIBLE MATCHES">
      <a id="pcreapi-3_sect27" name="pcreapi-3_sect27" shape="rect"> </a>

      <h2>FINDING ALL POSSIBLE MATCHES</h2>

      <p>The traditional matching function uses a similar algorithm
      to Perl, which stops when it finds the first match, starting
      at a given point in the subject. If you want to find all
      possible matches, or the longest possible match, consider
      using the alternative matching function (see below) instead.
      If you cannot use the alternative function, but still need to
      find all possible matches, you can kludge it up by making use
      of the callout facility, which is described in the <a class="link" href="../htmlman3/pcrecallout.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrecallout</span>(3)</span></a>
      documentation.</p>

      <p>What you have to do is to insert a callout right at the
      end of the pattern. When your callout function is called,
      extract and save the current matched substring. Then return
      1, which forces <code class="function">pcre_exec</code>() to
      backtrack and try other alternatives. Ultimately, when it
      runs out of matches, <code class="function">pcre_exec</code>() will yield
      PCRE_ERROR_NOMATCH.</p>
    </div>

    <div class="refsect1" title="OBTAINING AN ESTIMATE OF STACK USAGE">
      <a id="pcreapi-3_sect28" name="pcreapi-3_sect28" shape="rect"> </a>

      <h2>OBTAINING AN ESTIMATE OF STACK USAGE</h2>

      <p>Matching certain patterns using <code class="function">pcre_exec</code>() can use a lot of process stack,
      which in certain environments can be rather limited in size.
      Some users find it helpful to have an estimate of the amount
      of stack that is used by <code class="function">pcre_exec</code>(), to help them set recursion
      limits, as described in the <a class="link" href="../htmlman3/pcrestack.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrestack</span>(3)</span></a> documentation.
      The estimate that is output by <span class="command"><strong>pcretest</strong></span> when called with
      the <code class="option">−m</code> and <code class="option">−C</code> options is obtained by calling
      <code class="function">pcre_exec</code> with the values NULL,
      NULL, NULL, -999, and -999 for its first five arguments.</p>

      <p>Normally, if its first argument is NULL, <code class="function">pcre_exec</code>() immediately returns the
      negative error code PCRE_ERROR_NULL, but with this special
      combination of arguments, it returns instead a negative
      number whose absolute value is the approximate stack frame
      size in bytes. (A negative number is used so that it is clear
      that no match has happened.) The value is approximate because
      in some cases, recursive calls to <code class="function">pcre_exec</code>() occur when there are one or two
      additional variables on the stack.</p>

      <p>If PCRE has been compiled to use the heap instead of the
      stack for recursion, the value returned is the size of each
      block that is obtained from the heap.</p>
    </div>

    <div class="refsect1" title="MATCHING A PATTERN: THE ALTERNATIVE FUNCTION">
      <a id="pcreapi-3_sect29" name="pcreapi-3_sect29" shape="rect"> </a>

      <h2>MATCHING A PATTERN: THE ALTERNATIVE FUNCTION</h2>

      <div class="funcsynopsis">
        <table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table">
          <tr>
            <td rowspan="1" colspan="1"><code class="funcdef">int
            <strong>pcre_dfa_exec</strong>(</code></td>

            <td rowspan="1" colspan="1">const pcre *<var class="pdparam">code</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const pcre_extra *<var class="pdparam">extra</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">const char *<var class="pdparam">subject</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">length</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">startoffset</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">options</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">ovector</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">ovecsize</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int *<var class="pdparam">workspace</var>,</td>
          </tr>

          <tr>
            <td rowspan="1" colspan="1"> </td>

            <td rowspan="1" colspan="1">int <var class="pdparam">wscount</var><code>)</code>;</td>
          </tr>
        </table>

        <div class="funcprototype-spacer">
           
        </div>
      </div>

      <p>The function <code class="function">pcre_dfa_exec</code>()
      is called to match a subject string against a compiled
      pattern, using a matching algorithm that scans the subject
      string just once, and does not backtrack. This has different
      characteristics to the normal algorithm, and is not
      compatible with Perl. Some of the features of PCRE patterns
      are not supported. Nevertheless, there are times when this
      kind of matching can be useful. For a discussion of the two
      matching algorithms, and a list of features that <code class="function">pcre_dfa_exec</code>() does not support, see the
      <a class="link" href="../htmlman3/pcrematching.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrematching</span>(3)</span></a>
      documentation.</p>

      <p>The arguments for the <code class="function">pcre_dfa_exec</code>() function are the same as
      for <code class="function">pcre_exec</code>(), plus two
      extras. The <em class="parameter"><code>ovector</code></em>
      argument is used in a different way, and this is described
      below. The other common arguments are used in the same way as
      for <code class="function">pcre_exec</code>(), so their
      description is not repeated here.</p>

      <p>The two additional arguments provide workspace for the
      function. The workspace vector should contain at least 20
      elements. It is used for keeping track of multiple paths
      through the pattern tree. More workspace will be needed for
      patterns and subjects where there are a lot of potential
      matches.</p>

      <p>Here is an example of a simple call to <code class="function">pcre_dfa_exec</code>():</p>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
 int rc;
 int ovector[10];
 int wspace[20];
 rc = pcre_dfa_exec(
   re,             /* result of pcre_compile() */
   NULL,           /* we didn't study the pattern */
   "some string",  /* the subject string */
   11,             /* the length of the subject string */
   0,              /* start at offset 0 in the subject */
   0,              /* default options */
   ovector,        /* vector of integers for substring information */
   10,             /* number of elements (NOT size in bytes) */
   wspace,         /* working space vector */
   20);            /* number of elements (NOT size in bytes) */
</pre>
      </div>

      <div class="refsect2" title="Option bits for pcre_dfa_exec()">
        <a id="pcreapi-3_sect30" name="pcreapi-3_sect30" shape="rect"> </a>

        <h3>Option bits for <code class="function">pcre_dfa_exec</code>()</h3>

        <p>The unused bits of the <em class="parameter"><code>options</code></em> argument for
        <code class="function">pcre_dfa_exec</code>() must be zero.
        The only bits that may be set are PCRE_ANCHORED,
        PCRE_NEWLINE_<em class="replaceable"><code>xxx</code></em>,
        PCRE_NOTBOL, PCRE_NOTEOL, PCRE_NOTEMPTY,
        PCRE_NOTEMPTY_ATSTART, PCRE_NO_UTF8_CHECK,
        PCRE_BSR_ANYCRLF, PCRE_BSR_UNICODE, PCRE_NO_START_OPTIMIZE,
        PCRE_PARTIAL_HARD, PCRE_PARTIAL_SOFT, PCRE_DFA_SHORTEST,
        and PCRE_DFA_RESTART. All but the last four of these are
        exactly the same as for <code class="function">pcre_exec</code>(), so their description is not
        repeated here.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
 PCRE_PARTIAL_HARD
 PCRE_PARTIAL_SOFT
</pre>
        </div>

        <p>These have the same general effect as they do for
        <code class="function">pcre_exec</code>(), but the details
        are slightly different. When PCRE_PARTIAL_HARD is set for
        <code class="function">pcre_dfa_exec</code>(), it returns
        PCRE_ERROR_PARTIAL if the end of the subject is reached and
        there is still at least one matching possibility that
        requires additional characters. This happens even if some
        complete matches have also been found. When
        PCRE_PARTIAL_SOFT is set, the return code
        PCRE_ERROR_NOMATCH is converted into PCRE_ERROR_PARTIAL if
        the end of the subject is reached, there have been no
        complete matches, but there is still at least one matching
        possibility. The portion of the string that was inspected
        when the longest partial match was found is set as the
        first matching string in both cases. There is a more
        detailed discussion of partial and multi-segment matching,
        with examples, in the <a class="link" href="../htmlman3/pcrepartial.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrepartial</span>(3)</span></a>
        documentation.</p>

        <div class="variablelist">
          <dl>
            <dt><span class="term"><code class="constant">PCRE_DFA_SHORTEST</code></span></dt>

            <dd>
              <p>Setting the PCRE_DFA_SHORTEST option causes the
              matching algorithm to stop as soon as it has found
              one match. Because of the way the alternative
              algorithm works, this is necessarily the shortest
              possible match at the first possible matching point
              in the subject string.</p>
            </dd>

            <dt><span class="term"><code class="constant">PCRE_DFA_RESTART</code></span></dt>

            <dd>
              <p>When <code class="function">pcre_dfa_exec</code>()
              returns a partial match, it is possible to call it
              again, with additional subject characters, and have
              it continue with the same match. The PCRE_DFA_RESTART
              option requests this action; when it is set, the
              <em class="parameter"><code>workspace</code></em> and
              <em class="parameter"><code>wscount</code></em>
              options must reference the same vector as before
              because data about the match so far is left in them
              after a partial match. There is more discussion of
              this facility in the <a class="link" href="../htmlman3/pcrepartial.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrepartial</span>(3)</span></a>
              documentation.</p>
            </dd>
          </dl>
        </div>
      </div>

      <div class="refsect2" title="Successful returns from pcre_dfa_exec()">
        <a id="pcreapi-3_sect31" name="pcreapi-3_sect31" shape="rect"> </a>

        <h3>Successful returns from <code class="function">pcre_dfa_exec</code>()</h3>

        <p>When <code class="function">pcre_dfa_exec</code>()
        succeeds, it may have matched more than one substring in
        the subject. Note, however, that all the matches from one
        run of the function start at the same point in the subject.
        The shorter matches are all initial substrings of the
        longer matches. For example, if the pattern</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
&lt;.*&gt;
</pre>
        </div>

        <p>is matched against the string</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
This is &lt;something&gt; &lt;something else&gt; &lt;something further&gt; no more
</pre>
        </div>

        <p>the three matched strings are</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
 &lt;something&gt;
 &lt;something&gt; &lt;something else&gt;
 &lt;something&gt; &lt;something else&gt; &lt;something further&gt;
</pre>
        </div>

        <p>On success, the yield of the function is a number
        greater than zero, which is the number of matched
        substrings. The substrings themselves are returned in
        <em class="parameter"><code>ovector</code></em>. Each
        string uses two elements; the first is the offset to the
        start, and the second is the offset to the end. In fact,
        all the strings have the same start offset. (Space could
        have been saved by giving this only once, but it was
        decided to retain some compatibility with the way
        <code class="function">pcre_exec</code>() returns data,
        even though the meaning of the strings is different.)</p>

        <p>The strings are returned in reverse order of length;
        that is, the longest matching string is given first. If
        there were too many matches to fit into <em class="parameter"><code>ovector</code></em>, the yield of the
        function is zero, and the vector is filled with the longest
        matches. Unlike <code class="function">pcre_exec</code>(),
        <code class="function">pcre_dfa_exec</code>() can use the
        entire <em class="parameter"><code>ovector</code></em> for
        returning matched strings.</p>
      </div>

      <div class="refsect2" title="Error returns from pcre_dfa_exec()">
        <a id="pcreapi-3_sect32" name="pcreapi-3_sect32" shape="rect"> </a>

        <h3>Error returns from <code class="function">pcre_dfa_exec</code>()</h3>

        <p>The <code class="function">pcre_dfa_exec</code>()
        function returns a negative number when it fails. Many of
        the errors are the same as for <code class="function">pcre_exec</code>(), and these are described
        above. There are in addition the following errors that are
        specific to <code class="function">pcre_dfa_exec</code>():</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_DFA_UITEM      (-16)
</pre>
        </div>

        <p>This return is given if <code class="function">pcre_dfa_exec</code>() encounters an item in the
        pattern that it does not support, for instance, the use of
        \C or a back reference.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_DFA_UCOND      (-17)
</pre>
        </div>

        <p>This return is given if <code class="function">pcre_dfa_exec</code>() encounters a condition
        item that uses a back reference for the condition, or a
        test for recursion in a specific group. These are not
        supported.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_DFA_UMLIMIT    (-18)
</pre>
        </div>

        <p>This return is given if <code class="function">pcre_dfa_exec</code>() is called with an
        <em class="parameter"><code>extra</code></em> block that
        contains a setting of the <em class="parameter"><code>match_limit</code></em> or <em class="parameter"><code>match_limit_recursion</code></em> fields.
        This is not supported (these fields are meaningless for DFA
        matching).</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_DFA_WSSIZE     (-19)
</pre>
        </div>

        <p>This return is given if <code class="function">pcre_dfa_exec</code>() runs out of space in the
        <em class="parameter"><code>workspace</code></em>
        vector.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_DFA_RECURSE    (-20)
</pre>
        </div>

        <p>When a recursive subpattern is processed, the matching
        function calls itself recursively, using private vectors
        for <em class="parameter"><code>ovector</code></em> and
        <em class="parameter"><code>workspace</code></em>. This
        error is given if the output vector is not large enough.
        This should be extremely rare, as a vector of size 1000 is
        used.</p>

        <div class="informalexample">
          <pre class="programlisting" xml:space="preserve">
PCRE_ERROR_DFA_BADRESTART (-30)
</pre>
        </div>

        <p>When <code class="function">pcre_dfa_exec</code>() is
        called with the <code class="constant">PCRE_DFA_RESTART</code> option, some
        plausibility checks are made on the contents of the
        workspace, which should contain data about the previous
        partial match. If any of these checks fail, this error is
        given.</p>
      </div>
    </div>

    <div class="refsect1" title="SEE ALSO">
      <a id="pcreapi-3_sect33" name="pcreapi-3_sect33" shape="rect"> </a>

      <h2>SEE ALSO</h2>

      <p><a class="link" href="../htmlman3/pcre16.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcre16</span>(3)</span></a>, <a class="link" href="../htmlman3/pcrebuild.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrebuild</span>(3)</span></a>, <a class="link" href="../htmlman3/pcrecallout.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrecallout</span>(3)</span></a>,
      <span class="citerefentry"><span class="refentrytitle">pcrecpp(3)</span>(3)</span>, <a class="link" href="../htmlman3/pcrematching.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrematching</span>(3)</span></a>, <a class="link" href="../htmlman3/pcrepartial.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrepartial</span>(3)</span></a>, <a class="link" href="../htmlman3/pcreposix.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcreposix</span>(3)</span></a>, <a class="link" href="../htmlman3/pcreprecompile.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcreprecompile</span>(3)</span></a>,
      <a class="link" href="../htmlman3/pcresample.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcresample</span>(3)</span></a>, <a class="link" href="../htmlman3/pcrestack.3.html" target="_top" shape="rect"><span class="citerefentry"><span class="refentrytitle">pcrestack</span>(3)</span></a>.</p>
    </div>

    <div class="refsect1" title="AUTHOR">
      <a id="pcreapi-3_sect34" name="pcreapi-3_sect34" shape="rect"> </a>

      <h2>AUTHOR</h2>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
Philip Hazel
University Computing Service
Cambridge CB2 3QH, England.
</pre>
      </div>
    </div>

    <div class="refsect1" title="REVISION">
      <a id="pcreapi-3_sect35" name="pcreapi-3_sect35" shape="rect"> </a>

      <h2>REVISION</h2>

      <div class="informalexample">
        <pre class="programlisting" xml:space="preserve">
Last updated: 17 June 2012
Copyright (c) 1997-2012 University of Cambridge.
</pre>
      </div>

      <div class="license">
        <table style="border-collapse: collapse;">
          <colgroup span="1">
            <col span="1" />
          </colgroup>

          <thead>
            <tr>
              <th style="" rowspan="1" colspan="1">COPYRIGHT</th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td style="" rowspan="1" colspan="1">
                <p>This manual page is taken from the <a class="ulink" href="http://www.PCRE.org/" target="_top" shape="rect">PCRE library</a>, which is distributed under
                the BSD license.</p>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
  </div>
</body>
</html>
